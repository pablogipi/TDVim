"
" Main Vim setup in single file without any external plugin dependencies
"
" Mantainer:	Pablo Gimenez <pablogipi@gmail.com>
" Last change:	2009 Dec 9
"
"

" Sections:
" - Functions
" - Init settings
" - Terminal Settings
" - Search settings
" - Keyboard mappings
" - Interface settings
" - Edit options and Language specific options
" - Diff mode specific options
" - Autocommands
" - Custom commands
" - Global variables
"

" Global variables {{{


" }}}

" Functions {{{

" GetOS {{{2
" Get host OS: 
" 0: Unkmown OS
" 1: UNIX (usually Linux), no Mac
" 2: MacOS
" 3: Windows
function! s:GetOS()
    if has("win32") || has("win64") || has("win32unix")
        return 3
    elseif has("mac") || has("macunix")
        return 2
    elseif has("unix")
        return 1
    else
        return 0
    endif
endf
" }}}


" getWinInfo {{{2
" winid: id of the window, if not passed then current window will be used
"function! s:getWinInfo( winid=-1 )
function! s:getWinInfo( winid )
    let curwin = a:winid
    if curwin == -1
        let curwin = winnr()
    endif
    let wininfos = getwininfo()
    for idx in range( len( wininfos ) )
        let wininfo = wininfos[ idx ]
        if wininfo['winnr'] == curwin
            return wininfo
        endif
    endfor
    return {}
endfunction
" }}}

" NeatFoldText {{{2
" Improve text for folding line
function! s:NeatFoldText()
    let line = ' ' . substitute(getline(v:foldstart), '^\s*"\?\s*\|\s*"\?\s*{{' . '{\d*\s*', '', 'g') . ' '
    let lines_count = v:foldend - v:foldstart + 1
    let lines_count_text = '| ' . printf("%10s", lines_count . ' lines') . ' |'
    let foldchar = matchstr(&fillchars, 'fold:\zs.')
    let foldtextstart = strpart('+' . repeat(foldchar, v:foldlevel*2) . line, 0, (winwidth(0)*2)/3)
    let foldtextend = lines_count_text . repeat(foldchar, 8)
    let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
    return foldtextstart . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
endfunction
" }}}

" SetLocalPath {{{2
" Set the local path for the current buffer to the folder that contains the
" loaded file
function! s:SetLocalPath ()
    " Current basename for the buffer
    let baseName = expand("%:p:h")
    if isdirectory(baseName)
        silent! exe 'lcd ' . fnameescape(baseName)
    endif
endfunction
" }}}

" SetupAuxBuffer {{{2
" Setup common settings for auxiliary windows like quickfix and preview
" Setups done:
" Set q and <Esc> as keymaps to close the window
function! s:SetupAuxBuffer( )
     "echomsg "Calling setup for qickfix buffer"
    " Aux buffers local maps
    " Close window with Esc or q
    map <silent> <buffer> <Esc> :bdelete <bar> wincmd p<CR>
    map <silent> <buffer> q :bdelete <bar> wincmd p<CR>

    "For quickfix and location list disable buffer in buffers list
    if 'quickfix' ==# &buftype
        let wininfo = s:getWinInfo( -1 )
        " Move quickfix to the bottom
        if wininfo['quickfix'] && !wininfo['loclist']
            wincmd J
        endif
        setlocal nobuflisted
        setlocal cursorline
    endif

endfunction
" }}}

" JumpToWindowsByType {{{2
" Given a buffer type, jump to it.
" Used to jump to quickfix, preview or location windows
" Check against:
" - Buffer type
" - File Type
" - Preview Window
function! TDVimJumpToWindowsByType ( buffertype )
  " Save current window number to revert.
  let save_winnr = winnr()
  let nwin = 1
  while 1
      let nbuf = winbufnr(nwin)
      " After all window processed, finish.
      if nbuf == -1
          break
      endif
      " Close window if its buftype is same as buffertype argument.  If not help, go to next window.
      "echo "Look into window " . nwin . ", buffer type: " . getbufvar(nbuf, '&buftype')
      let cond1 = getbufvar(nbuf, '&buftype') ==# a:buffertype
      let cond2 = getbufvar(nbuf, '&filetype') ==# a:buffertype
      let cond3 = "preview" ==# a:buffertype ? getwinvar(nwin, '&previewwindow') : 0
      " quickfix buffer type is a special case, it can be quickfix or location
      " list
      if "quickfix" ==# a:buffertype || "location" ==# a:buffertype
          " Get current window info
          let wininfo = s:getWinInfo( nwin )
          let islocwin = wininfo['loclist']
          let cond1 = 0
          if "quickfix" ==# a:buffertype && wininfo['quickfix'] && !wininfo['loclist']
              let cond1 = 1
          endif
          if "location" ==# a:buffertype && wininfo['quickfix'] && wininfo['loclist']
              let cond1 = 1
          endif
          "echomsg "Type: " . a:buffertype . " ,Condition: " . cond1
      endif
      if "qf" ==# a:buffertype
          " Get current window info
          let wininfo = s:getWinInfo( nwin )
          let cond2 = wininfo['quickfix'] && !wininfo['loclist']
      endif
      if cond1 || cond2 || cond3
          "echomsg "Correct!, jump to window " . nwin
          " Correct saved window number if younger window will be closed.
          if save_winnr > nbuf
              let save_winnr = save_winnr - 1
          endif
          execute nwin.'wincmd w'
          break
      "elseif cond3
          "" For preview window
          "let buffervars = getbufvar(nbuf, '&')
          "echo Vars:
          "echo buffervars
          "let cond = getwinvar(nwin, '&previewwindow')
          "echo "Window condition: " . cond
          "pclose
          "break
      else
          let nwin = nwin + 1
      endif
  endwhile
endfunction
" }}}

" PreviewWindowSetup {{{2
" Setup preview window depending based on previous window type.
" This is mainly used to offer a better preview for tags and other
" development help.
" Usage: call this using a BufWinEnter autocommand
function! s:PreviewWindowSetup()
    if &previewwindow			" if we really are at the preview window
        "echomsg "In Preview window!!"
        if &filetype == ""
            " Tags preview
            set filetype=passwd 
        else
            " Preview jump to tag
                                " silent! foldopen!   " Disable folds
            set nofoldenable
            setlocal cursorline " Highlight current line
            set number          " Set line numbers
            set ro              " Force Read-Only
        endif
        " Preview buffers local maps
        map <silent> <buffer> <Esc> :bdelete <bar> wincmd p<CR>
        map <silent> <buffer> q :bdelete <bar> wincmd p<CR>
        " Move preview window to the very bottom
        wincmd J
        " But keep Quickfix window at the bottom :)
        call TDVimJumpToWindowsByType( 'quickfix' )
        wincmd J
        " Go back to preview
        wincmd P
    endif
endfunction
" }}}

" LeavePreviewWindowSetup {{{2
" Setup preview window when leaving it
" Usage: call this using a BufWinLeave autocommand
 function! s:LeavePreviewWindowSetup ()
    if &previewwindow			" if we really are at the preview window
        " Restore buffer editable
        set noro
    endif
 endfunction
"
" }}}

" TabAutocompleteWrapper {{{2
" Function to call to Autocomplete when pressing TAB
" Or insert a TAB if there is nothing in front of the cursor
" From: https://stackoverflow.com/questions/2055417/mapping-tab-to-omicompletion-in-gvim 
function! TDVimTabAutocompleteWrapper( direction)
  " Make TAB working in popup menu
  if pumvisible()
    if "backward" == a:direction
      return "\<C-P>"
    else
      return "\<C-N>"
    endif
  endif
  " Pass a normal TAB if there is no character in front.
  " Use autocomplete if there is something in front of the cursor
  let char_before = col('.') - 1
  if !char_before || getline('.')[char_before - 1] !~ '\k'
    "if "backward" == a:direction
    "return "\<BS>"
    "else
    "return "\<tab>"
    "endif
    return "\<tab>"
  elseif "backward" == a:direction
    return "\<c-p>"
  else
    return "\<c-n>"
  endif
endfunction
" }}}

" CreateOrJumpToTerminal {{{2
" Try to jump to an existing terminal, if succesful then restore window size
" If not then create a new terminal
function! TDVimCreateOrJumpToTerminal ( )
  call TDVimJumpToWindowsByType("terminal")
  if &buftype == "terminal"
    wincmd =
    " echo "In terminal"
  else
    " wincmd b | botright terminal<CR>
    botright terminal
  endif
  " wincmd J
endfunction
" }}}

" CloseAllWindowsByType {{{2
" Close all windows for a given buffertype
function! TDVimCloseAllWindowsByType( buffertype )
    " For preview window just run pclose and exit:
    if "preview" ==# a:buffertype
        pclose
        return
    endif
  " Save current window number to revert.
  let sel_winnr = winnr()
  let nwin = 1
  while 1
      let nbuf = winbufnr(nwin)
      " After all window processed, finish.
      if nbuf == -1
          break
      endif
      " Close window if its buftype is same as buffertype argument.  If not help, go to next window.
      if getbufvar(nbuf, '&buftype') ==# a:buffertype
          " Correct saved window number if younger window will be closed.
          if sel_winnr > nbuf
              let sel_winnr = sel_winnr - 1
          endif
          execute nwin.'wincmd w'
          " If there is only one help window, quit.
          if nwin == 1 && winbufnr(2) == -1
              quit!
          else
              close!
          endif
      else
          let nwin = nwin + 1
      endif
  endwhile
  " Revert selected window.
  "execute save_winnr.'wincmd w' , silent!
  silent! sel_winnr.'wincmd w'
endfunction
" }}}

" ClosePreviousWindow {{{2
" Close previous window
function! TDVimClosePreviousWindow()
    let prevwindow = winnr('#')
    if prevwindow > 0
        execute prevwindow . 'wincmd c'
    endif
endfunction
" }}}

" SetupNERDTreeBuffer {{{
" Functiom to do some custom setups in a NERDtree buffer when Syntax event
" is triggered usinh autocommands.
" Close NERDtree window using - or Esc.
function! s:SetupNERDTreeBuffer(  )
    " Check we are actually in a NERDTree buffer
    if &syntax !~ "nerdtree"
        echoerr "We are NOT in a NERDtree buffer!!!: " . curbuf
        return
    endif
    "echomsg "We are in a NERDtree buffer!!!"
    nmap <buffer> -        :call nerdtree#ui_glue#invokeKeyMap("q")<CR>
    nmap <buffer> <silent> <Esc> :call nerdtree#ui_glue#invokeKeyMap("q")<CR>
endfunction
" }}}

" }}}

" Init settings {{{
"
" When started as "evim", evim.vim will already have done these settings.
if v:progname =~? "evim"
    finish
endif


" Use Vim settings, rather then Vi settings (much better!).
" This must be first, because it changes other options as a side effect.
set nocompatible
" Allow backspacing over everything in insert mode
set backspace=indent,eol,start

" Backup and swap files
" Do not keep a backup file for VMS
if has("vms")
    set nobackup
else
    set backup                               " keep a backup file
endif
let vimbackuppath = $HOME . '/.vim/tmp'
if has('win32') || has('win64')
    "Windows
    let vimbackuppath = $HOME . '/vimfiles/tmp'
endif
let &backupdir = vimbackuppath . '//,.'
let &directory = vimbackuppath . '//,.'
silent call mkdir (vimbackuppath , 'p')

" Set viminfo. Mainly set history limits
" File history: 25
" Maximum lines per registry: 100
" Maximum sze of a register: 10KB
" Disable hlsearch
set viminfo='25,<100,s10,h
if s:GetOS() == 3
    "Windows
    set viminfo+=rA:
    set viminfo+=rB:
endif


" Check terminals colors, if is not a 256 color terminal make a warning
if !has('gui_running') && &t_Co < 256
  silent echomsg "Current terminal doesn't support 256 colors. Some colors and the status line won't look correctly"
else
  " Gives Vim access to a broader range of colours
  set termguicolors
endif


" Always run mswin at the end
" Load more conventional editors options, MSWin mode:
source $VIMRUNTIME/mswin.vim
" Fix mswin, it enters in select mode rather than visual.
set selectmode=""
" Auto change directory
set autochdir
" Use OS clipboard:
set clipboard^=unnamed,unnamedplus

" }}}

" Sessions {{{
" Options for what to save in the sessions file:
let &sessionoptions='buffers,curdir,folds,resize,winsize'
"let &sessionoptions-='help'
"let &sessionoptions+='resize'
" View, restore file state options:
let &viewoptions='cursor,folds,slash,unix'

" }}}

" Terminal settings {{{
set ttyfast
" set term gui colors (most terminals support this)
set termguicolors

" }}}

" Edit options and Language specific options {{{
"
" Switch syntax highlighting on, when the terminal has colors
" Also switch on highlighting the last used search pattern.
if &t_Co > 2 || has("gui_running")
    syntax on
    set hlsearch
endif

" Set buffers to be hidden for easy switching
set hidden
" Consider windows in other tabs when opening a buffer
set switchbuf=usetab

" Default editing setup:
" Settings common for all file types:

" Tabs width
let &shiftwidth  = 4
let &softtabstop = 4
let &shiftwidth  = 4
" Size for the TAB
let &tabstop=&shiftwidth
set expandtab
" Always round indent to shiftwidth
set shiftround
" Line numbering for all file formats:
set number
" Better folding:
set foldtext=s:NeatFoldText()

set whichwrap+=<,>,[,],h,l
set iskeyword+=-
set formatoptions-=cro

" Search settings {{{

" Activate showmatch
set showmatch
" Do incremental searching
set incsearch
" Switch on search pattern highlighting.
set hlsearch
" Search case mode:
set ignorecase
set smartcase
" make indenting smarter again
set smartindent
" Global search by default
set gdefault
" Better grep
if executable("rg")
  set grepprg=rg\ --vimgrep
  set grepformat=%f:%l:%c:%m
elseif executable("ag")
  set grepprg=ag\ --vimgrep\ --ignore\ *~\ --ignore\ *.swp\ --ignore\ *.diff\ --ignore\ tags\ --ignore\ *.tags
  set grepformat=%f:%l:%c:%m
endif

" }}}

" }}}

" Interface settings {{{
"
"Encoding {{{2
" UTF-8 encoding has been disabled due to several compatibility problems
" Spacially with terminals.
if has("multi_byte")
    if &termencoding == ""
        let &termencoding = &encoding
    endif
    set encoding=utf-8
    "setglobal fileencoding=utf-8 bomb
    setglobal fileencoding=utf-8
    set fileencodings=ucs-bom,utf-8,latin1
endif
"}}}

" In many terminal emulators the mouse works just fine, thus enable it.
set mouse=a

" Color Theme
" Leave this for the user settings, use default
colorscheme desert

" Preview Window Height
set previewheight=8
" pop up menu height
set pumheight=10
" set number column width to 4 {default 4}
set numberwidth=4
" always show the sign column, otherwise it would shift the text each time
set signcolumn=yes

" Folding options: {{{2
" Default folding method id indent
set foldmethod=indent
" Folds margin width
set foldcolumn=2
" Minimum lines in a  fold to consider it a a proper fold
set foldminlines=3
" Fold starting level, set to 1 to have only level 1 folds ready
set foldlevelstart=-1
" Max nested level
let &foldnestmax=3
" }}}

" Tabs label format:
"set guitablabel=%{utils#GuiTabLabel()}
" Always show tabs
set showtabline=2


" Status Line {{{2
" Always show status line:
set laststatus=2
" Defaul status line
set statusline=%-f%m%r%h%w%q\ %y\ %=[POS=%l,%v][%p%%]
" Disable show mode, not needed when using lighline or any other status line
" plugin
set noshowmode


" }}}

" Preview window {{{2
set pvh=5
" }}}

" Invisible character {{{2
"set listchars=tab:▸\ ,eol:¬
set listchars=tab:>-,eol:¬,space:.,trail:.
" }}}

" Lines wraping and formatting {{{2
set wrap
set textwidth=79
set formatoptions=qrn1
" }}}


" FoldDigest {{{2
if exists("$FOLDDIGEST_POS")
    let g:FoldDigest_Pos=$FOLDDIGEST_POS
else
    let g:FoldDigest_Pos="right"
endif

" }}}

" Netrw {{{2
let g:netrw_sort_sequence = '[\/]$,*'
"let g:netrw_browse_split  = 4
let g:netrw_banner=0        " disable annoying banner
let g:netrw_browse_split=0  " open in prior window
let g:netrw_altv=1          " open splits to the right
let g:netrw_liststyle=3     " tree view
let g:netrw_list_hide=netrw_gitignore#Hide()
let g:netrw_list_hide.=',\(^\|\s\s\)\zs\.\S\+'
let g:netrw_sizestyle="H"   " Human readable sizes
" }}}

" Command line {{{2
set history=50                           " keep 50 lines of command line history
" Command line height
set cmdheight=2

" Command Line Complete Menu
set wildmenu
set wildmode=list:longest,full            " Complete the next full match
" Ignores patterns in autocomplete
if s:GetOS() == 1
    "Linux
    set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*.swp,*.bak,*~,*.o,*.obj,*.pyc,tags,cscope*
elseif s:GetOS() == 2
    "Mac
    set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*.swp,*.bak,*~,*.o,*.obj,*.pyc,tags,cscope*
elseif s:GetOS() == 3
    "Windows
    set wildignore+=*\\.git\\*,*\\.hg\\*,*\\.svn\\*,*.swp,*.bak,*~,*.o,*.obj,*.pyc,tags,cscope*
endif
" Search down into subfolders
" Provides tab-completion for all file-related tasks
set path+=**
" }}}

"""""""""""""""""""""""""""
""""""""""""""""""""""""""" }}}

" GUI {{{
if has("gui_running")
    set mousehide		" Hide the mouse when typing text
    set mousemodel=popup	" Enable popup menu using mouse

    " Set GUI font and general options
    if has('gui_gtk2') || has('gui_gtk3')
        set gfn=DejaVu\ Sans\ Mono\ 10
        "set guioptions = "agimrLtT"
        set guioptions += "aAgimrLt"
    elseif has('gui_photon')
        set gfn=DejaVu\ Sans\ Mono:s10
    elseif has('gui_kde')
        " the obsolete kvim
        " just make sure it works correctly if it hits our vimrc
        set gfn=DejaVu\ Sans\ Mono/10/-1/5/50/0/0/0/1/0
    elseif has('x11')
        " I'm guessing the following (other-X11 including GTK1)
        " please check, and correct if necessary.
        " On GTK1 (and maybe some others) you can use :set gfn=*
        " Replace by asterisks like here
        " to make it a little more general:
        set gfn=-*-dejavu-medium-r-normal-*-*-10-*-*-m-*-*
        " add another elseif here
        " if you want DejaVu on mac-without-x11
    elseif has("gui_macvim") || has("gui_mac")
        set gfn=DejaVu\ Sans\ Mono:h13
    elseif has("win32")
        set guioptions+="gmrLtT"
        set guifont=Consolas:h11:cANSI:qDRAFT
    else
        " system not detected
    endif

    " Better updatetime for GUI
    set updatetime=1000


endif
" }}}

" Custom commands {{{
" TODO:
" Create Tags file in current location
command! TDVimMakeTags !ctags -R  --sort=1 --c++-kinds=+p --fields=+iaS --extras=+q --exclude='.git' --exclude='.svn' --exclude='*.so' --exclude='__pycache__' --exclude='*.pyc'  
" Jump to existing terminal and restore or create a new terminal
command! TDVimOpenTerminal call TDVimCreateOrJumpToTerminal()
" Run grep, allow user to mpdify initial pattern and then open quickfix window wit results
command! -nargs=+ TDvimGrep execute 'silent grep! <args>' | copen
" }}}

" Keyboard mappings {{{
" Leader key
"let mapleader = ","
"let mapleader = "`"
let mapleader = "\<Space>"
let maplocalleader = ","
" Load keymaps mapings for TDVim
" TODO

" Modes
"   normal_mode = "n",
"   insert_mode = "i",
"   visual_mode = "v",
"   visual_block_mode = "x",
"   term_mode = "t",
"   command_mode = "c",
"
"
" Modes {{{2
" Operations to change between modes

" Command Line Mode - F2
nnoremap  <F2>              :
xnoremap  <F2>              :
inoremap  <F2>              <ESC>:
tnoremap <F2>               <C-w>:

" Press jk fast exit Insert and enter Normal mode
imap  <silent> jk              <ESC>

" }}}

" Help {{{2
nnoremap  <S-F1>             :h <C-r><C-w><CR> 
xnoremap  <S-F1>             :h <C-r><C-w><CR> 
inoremap  <S-F1>             <C-O>:h <C-r><C-w><CR> 
" }}}

" Main Operations {{{2
" Main operations like open, save, new, quit, etc ...
" Open Files in current location - S-F3, <leader>o
nnoremap   <S-F3>   :find<space>
vnoremap   <S-F3>   :find<space>
inoremap   <S-F3>   <ESC>:find<space>
" Open Recent Files - C-S-F3
nnoremap   <C-S-F3>   :browse oldfiles<CR>
vnoremap   <C-S-F3>   :browse oldfiles<CR>
inoremap   <C-S-F3>   <ESC>:browse oldfiles<CR>
" Save - <leader>w
nnoremap   <leader>w    :w<CR>
" Save All - <leader>wa
nnoremap   <leader>wa   :wa<CR>
" Save All  and Quit
nnoremap   <F12>      :xa<CR>
xnoremap   <F12>      :xa<CR>
inoremap   <F12>      <ESC>:xa<CR>
tnoremap   <F12>      <C-W>:xa<CR>
" Close And Quit
nnoremap   <C-F12>    :confirm qa<CR>
xnoremap   <C-F12>    :confirm qa<CR>
inoremap   <C-F12>    <ESC>:confirm qa<CR>
tnoremap   <C-F12>    <C-W>:confirm qa<CR>
"}}}


" Edit {{{2
" Keymaps for editing operations

" Stay selection in indent mode
xnoremap  <silent> <             <gv
xnoremap  <silent> >             >gv

" Better copy in visual mode. Paste and dont loose clipboard
vnoremap  <silent> p            "_dP 

" Move selected text up and down - Alt-[Up|Down]
vnoremap  <silent> <A-j>            :m .+1<CR>== 
vnoremap  <silent> <A-k>            :m .-2<CR>== 
vnoremap  <silent> <A-Down>         :m .+1<CR>== 
vnoremap  <silent> <A-Up>           :m .-2<CR>== 

" Visual Block 
" Move text up and down - Alt-[Up|Down]
xnoremap  <silent> J           :move '>+1<CR>gv-gv 
xnoremap  <silent> K           :move '<-2<CR>gv-gv 
xnoremap  <silent> <A-j>       :move '>+1<CR>gv-gv 
xnoremap  <silent> <A-k>       :move '<-2<CR>gv-gv 
xnoremap  <silent> <A-Down>    :move '>+1<CR>gv-gv 
xnoremap  <silent> <A-Up>      :move '<-2<CR>gv-gv 


" Grep/Search word under cursor - F4, leader-g
" nnoremap  <F4>      :silent lgrep <C-R><C-W><CR>:lopen<CR>
" inoremap  <F4>      :<C-O>silent lgrep <C-R><C-W><CR>:lopen<CR>
" xnoremap  <F4>      :silent lgrep <C-R><C-W><CR>:lopen<CR>
nnoremap  <F4>          :TDvimGrep <C-R><C-W>
inoremap  <F4>          :<C-O>TDvimGrep  <C-R><C-W>
xnoremap  <F4>          :TDvimGrep  <C-R><C-W>
nnoremap  <leader>g     :TDvimGrep <C-R><C-W>
inoremap  <leader>g     :<C-O>TDvimGrep  <C-R><C-W>
xnoremap  <leader>g     :TDvimGrep  <C-R><C-W>

" Navigate Grep results. Navigate Location list entries
" Default mapped to []s
nmap <silent> [s :cprev<CR>
nmap <silent> ]s :cnext<CR>
nmap <silent> [S :cfirst<CR>
nmap <silent> ]S :clast<CR>

" Navigate Changes
" Default mapped to []c
nmap <silent> [c    g;
imap <silent> [c    <Esc>g;
vmap <silent> [c    g;
nmap <silent> ]c    g,
imap <silent> ]c    <Esc>g,
vmap <silent> ]c    g,





" }}}


" WindowManagement {{{2
" Operations to work with windows, tabs, etc ...

" Close Window - <leader>q
nnoremap  <silent> <leader>q          <C-w>c 
vnoremap  <silent> <leader>q          <C-w>c 
" Close All Help Windows - <leader>qh
nnoremap  <silent> <leader>qh         :call TDVimCloseAllWindowsByType('help')<CR> 
vnoremap  <silent> <leader>qh         :call TDVimCloseAllWindowsByType('help')<CR> 
" Close Preview Window - <leader>qp
nnoremap  <silent> <leader>qp         <C-W><C-Z> 
vnoremap  <silent> <leader>qp         <C-W><C-Z> 
inoremap  <silent> <leader>qp         <C-O><C-W><C-Z> 
" Close QuickFix Window - <leader>qq
nnoremap  <silent> <leader>qq         :cclose<CR> 
vnoremap  <silent> <leader>qq         <Esc>:cclose<CR> 
inoremap  <silent> <leader>qq         <Esc>:cclose<CR> 
" Close Location Window - <leader>ql
nnoremap  <silent> <leader>ql         :lclose<CR> 
vnoremap  <silent> <leader>ql         <Esc>:lclose<CR> 
inoremap  <silent> <leader>ql         <Esc>:lclose<CR> 
" Close Previous Window - <leader>qw
nnoremap  <silent> <leader>qw         :call TDVimClosePreviousWindow()<CR> 
vnoremap  <silent> <leader>qw         <Esc>:call TDVimClosePreviousWindow()<CR> 
inoremap  <silent> <leader>qw         <Esc>:call TDVimClosePreviousWindow()<CR> 

" Jump to QuickFix Window - <leader>jq
nnoremap  <silent> <leader>jq         :call utils#JumpToWindowsByType( "quickfix" )<CR> 
xnoremap  <silent> <leader>jq         <ESC>:call utils#JumpToWindowsByType( "quickfix" )<CR> 
inoremap  <silent> <leader>jq         <ESC>:call utils#JumpToWindowsByType( "quickfix" )<CR> 
" Jump to Location Window - <leader>jl
nnoremap  <silent> <leader>jl         :call utils#JumpToWindowsByType( "location" )<CR> 
xnoremap  <silent> <leader>jl         <ESC>:call utils#JumpToWindowsByType( "location" )<CR> 
inoremap  <silent> <leader>jl         <ESC>:call utils#JumpToWindowsByType( "location" )<CR> 
" Jump to Preview Window - <leader>jl
nnoremap  <silent> <leader>jp         :call utils#JumpToWindowsByType( "preview" )<CR> 
xnoremap  <silent> <leader>jp         <ESC>:call utils#JumpToWindowsByType( "preview" )<CR> 
inoremap  <silent> <leader>jp         <ESC>:call utils#JumpToWindowsByType( "preview" )<CR> 

" Jump to Location List Window {{{3
nnoremap <unique> <silent> <Plug>TdvimJumpToLocationWindow :call utils#JumpToWindowsByType( "location" )<CR>
vnoremap <unique> <silent> <Plug>TdvimJumpToLocationWindow <Esc>:call utils#JumpToWindowsByType( "location" )<CR>
inoremap <unique> <silent> <Plug>TdvimJumpToLocationWindow <Esc>:call utils#JumpToWindowsByType( "location" )<CR>

nmap <silent> <leader>jl <Plug>TdvimJumpToLocationWindow 
vmap <silent> <leader>jl <Plug>TdvimJumpToLocationWindow
" }}}

" Jump to Preview Window {{{3
nnoremap <unique> <silent> <Plug>TdvimJumpToPreviewWindow :call utils#JumpToWindowsByType( "preview" )<CR>
vnoremap <unique> <silent> <Plug>TdvimJumpToPreviewWindow <Esc>:call utils#JumpToWindowsByType( "preview" )<CR>
inoremap <unique> <silent> <Plug>TdvimJumpToPreviewWindow <Esc>:call utils#JumpToWindowsByType( "preview" )<CR>

nmap <silent> <leader>jp <Plug>TdvimJumpToPreviewWindow 
vmap <silent> <leader>jp <Plug>TdvimJumpToPreviewWindow
" }}}

" Close Window and Delete Buffer - <leader>x
nnoremap  <leader>x        :bdelete<CR> 
xnoremap  <leader>x        :bdelete<CR> 

" Vertical Split Window - <leader>s
nnoremap  <silent> <leader>s        <C-w>v 
vnoremap  <silent> <leader>s        <C-w>v 
" Horizontal Split Window - <leader>s
nnoremap  <silent> <leader>sh       <C-w>s 
vnoremap  <silent> <leader>sh       <C-w>s 

" Better window navigation - <leader>[Up|Down|Left|Right] {{{3
nnoremap  <silent> <C-h>    <C-w>h 
nnoremap  <silent> <C-l>    <C-w>l
nnoremap  <silent> <C-j>    <C-w>j
nnoremap  <silent> <C-k>    <C-w>k
nnoremap  <silent> <leader><Left>   <C-w>h
nnoremap  <silent> <leader><Right>  <C-w>l
nnoremap  <silent> <leader><Up>     <C-w>j 
nnoremap  <silent> <leader><Down>   <C-w>k
tnoremap  <silent> <C-h>    <C-w>h 
tnoremap  <silent> <C-l>    <C-w>l
tnoremap  <silent> <C-j>    <C-w>j
tnoremap  <silent> <C-k>    <C-w>k
tnoremap  <silent> <leader><Left>   <C-w>h
tnoremap  <silent> <leader><Right>  <C-w>l
tnoremap  <silent> <leader><Up>     <C-w>j 
tnoremap  <silent> <leader><Down>   <C-w>k
" }}}

" Explorer - F8, <leader>e
" Netrw
"nnoremap  <silent> <F8>       :Lex 20<cr> 
"nnoremap  <silent> <leader>e  :Lex 20<cr> 
" NErdtTree
nnoremap  <silent> <F8>       :NERDTreeToggle<cr> 
nnoremap  <silent> <leader>e  :NERDTreeToggle<cr> 
inoremap  <silent> <F8>       <C-O>:NERDTreeToggle<cr> 
xnoremap  <silent> <F8>       <ESC>:NERDTreeToggle<cr> 
" In Explorer - -
"nnoremap  <silent> -       :Explore<CR> 
"nnoremap  <silent> -       :Explore<CR> 

" Resize with arrows - Ctrl[Up|Down|Left|Right]
nnoremap  <silent> <C-Up>     :resize +2<CR> 
nnoremap  <silent> <C-Down>   :resize -2<CR> 
nnoremap  <silent> <C-Left>   :vertical resize -2<CR> 
nnoremap  <silent> <C-Right>  :vertical resize +2<CR> 
tnoremap  <silent> <C-Up>     :resize +2<CR> 
tnoremap  <silent> <C-Down>   :resize -2<CR> 
tnoremap  <silent> <C-Left>   :vertical resize -2<CR> 
tnoremap  <silent> <C-Right>  :vertical resize +2<CR> 

" Reset windows sizes - <leader>=
nnoremap  <silent> <leader>=   <C-w>= 
vnoremap  <silent> <leader>=   <C-w>= 
tnoremap  <silent> <leader>=   <C-w>= 

" Navigate buffers - []b
nnoremap  <silent> <S-l>=   :bnext<CR> 
nnoremap  <silent> <S-h>=   :bprevious<CR> 
nnoremap  <silent> <[b>=    :bnext<CR> 
nnoremap  <silent> <]b>=    :bprevious<CR> 

" Switch to Previous window
nnoremap  <silent> <leader>p   <C-w>p 
tnoremap  <silent> <leader>p   <C-w>p 
" Switch to Previous buffer - Ctrl-F3, <leader>TAB
nnoremap  <silent> <C-F3>   :e #<CR>
vnoremap  <silent> <C-F3>   :e #<CR>
inoremap  <silent> <C-F3>   <ESC>:e #<CR>
nnoremap  <silent> <leader><TAB>   :e #<CR>
vnoremap  <silent> <leader><TAB>   :e #<CR>

" Navigate Buffers - F3, <leader>b
nnoremap   <F3>   :files<cr>:b<space>
vnoremap   <F3>   :files<cr>:b<space>
inoremap   <F3>   <ESC>:files<cr>:b<space>

" }}}

" CommandLine {{{2
" Keymaps to work from the command line

" }}}

" Development {{{2
" Operations usually used when programing

" Toggel comments
nmap <silent> <F5>       <Plug>NERDCommenterToggle
vmap <silent> <F5>       <Plug>NERDCommenterToggle
imap <silent> <F5>       <Esc>\c<Space>
nmap <silent> <leader>ct <Plug>NERDCommenterToggle
vmap <silent> <leader>ct <Plug>NERDCommenterToggle

" Inspect and jump to tags
nnoremap   <F6>   :tjump <C-r><C-w><space>
xnoremap   <F6>   :tjump <C-r><C-w><space>
" Unimpaired tags navigation style with []t
nnoremap   ]t   :tjump <C-r><C-w><CR>
nnoremap   [t   <C-t>
" Inspect and preview tag
nnoremap   <S-F6>   :ptjump <C-r><C-w><space>
xnoremap   <S-F6>   :ptjump <C-r><C-w><space>


" Create tags file
nnoremap   <F11>   :TDVimMakeTags <CR>

" Autocomplete using Previous and Next
inoremap   <TAB>    <C-R>=TDVimTabAutocompleteWrapper("backward")<CR>
inoremap   <S-TAB>  <C-R>=TDVimTabAutocompleteWrapper("forward")<CR>
" keymap("i", "<tab>", "<c-r>=utils#TabAutocompleteWrapper(\"backward\")<cr>", opts)
" keymap("i", "<s-tab>", "<c-r>=utils#TabAutocompleteWrapper(\"forward\")<cr>", opts)

" }}}

" Terminal {{{2
" Termnal keymaps
" nnoremap <F7>       :wincmd b \| botright terminal<CR>
" Open terminal at bottom
nnoremap <F7>       :TDVimOpenTerminal<CR>
nnoremap <leader>t  :wincmd b \| botright terminal<CR>
" Minimize terminal window and jump to previous window
tnoremap <F7>       <C-W>1_<C-W>W
" }}}


" }}}


" Diff mode specific options {{{
set diffopt=filler,vertical
if &diff
    "	setup for diff mode
endif

" }}}

" Completion {{{
" Completion options
set noshowmode
"set shortmess+=c
set shortmess=aTt
set noinfercase
set belloff+=ctrlg " If Vim beeps during completion
set belloff+=cursor " If Vim beeps during scrolling
set belloff+=all " If Vim beeps during scrolling
set completeopt-=preview
set completeopt+=menuone
set completeopt-=popup
" set completeopt+=noinsert
" set completeopt+=noselect
set completepopup=height:10,width:60,highlight:InfoPopu

" Sources for searching in completion mode
" Only include current buffer and buffer in other windows only
set complete=.,w,b,t
" Set window splits to be at bottom by default, used by preview window and
" quckfix
set splitbelow
" time to wait for a mapped sequence to complete (in milliseconds)
set timeoutlen=500
" }}}

"
" Autocommands and Events {{{
"

" Only do this part when compiled with support for autocommands.
if has("autocmd")
    " Enable file type detection.
    filetype plugin indent on

    " Setup events autocommands
    " Misc
    augroup tdvimMisc
        " Highlight type for extra white spaces at the end of a line
        autocmd ColorScheme * highlight ExtraWhitespace ctermbg=lightred guibg=lightred
        autocmd Syntax python,cpp,c,sh,csh,vim highlight ExtraWhitespace ctermbg=lightred guibg=lightred
    augroup END
        " TODO
	"autocmd VimEnter * call utils#SourceUserSettings()
        autocmd VimEnter * echomsg "TDVim (vim noplugins)" . $TDVIMVERSION . " loaded"
    augroup END
    " AfterBufferRead
    augroup tdvimAftertBufferRead
        " When editing a file, always jump to the last known cursor position.
        " Don't do it when the position is invalid or when inside an event handler
        " (happens when dropping a file on gvim).
        autocmd BufRead *
                    \ if line("'\"") > 0 && line("'\"") <= line("$") |
                    \   exe "normal! g`\"" |
                    \ endif
        " Change local path to the folder containing the current buffer:
        autocmd BufRead * call s:SetLocalPath()
        autocmd BufRead quickfix call s:SetupAuxBuffer()
        " Show bad spaces at the end of code lines:
        au BufRead,BufNewFile *.py,*.pyw,*.c,*.cpp,*.vim,*.h match ExtraWhitespace  /\s\+$/
    augroup END
    " BufEnter
    augroup tdvimBufEnter
        " Set local path to path of current file
        autocmd BufEnter * call s:SetLocalPath()
        " Call TDVim Project
        "autocmd BufEnter * call utils#ProjectSettings(expand("<afile>:p:h"), 0)
    augroup END
    " BufLeave
    "augroup tdvimBufLeave
    "augroup END
    " BufWinEnter
    augroup tdvimWinNew
        autocmd WinNew * call s:PreviewWindowSetup()
    augroup END
    augroup tdvimWinEnter
        autocmd WinEnter * call s:PreviewWindowSetup()
    augroup END
    " BufWinLeave
    augroup tdvimWinLeave
        autocmd WinLeave * call s:LeavePreviewWindowSetup()
    augroup END
    " BufAdd
    "augroup tdvimBufAdd
        " Setup quickfix and preview windows keymaps
        "autocmd BufAdd  * if &buftype == 'quickfix' | echo 'winenter' | endif
        "autocmd BufAdd  * echomsg "Adding buffer " . &buftype
        "autocmd BufAdd qf call utils#SetupAuxBuffer()
    "augroup END
     "FileTypes
     "
    augroup tdvimFileTypes
	"autocmd Filetype *
		    "\	if &omnifunc == "" |
		    "\		setlocal omnifunc=syntaxcomplete#Complete |
		    "\	endif
        autocmd FileType nerdtree call s:SetupNERDTreeBuffer()
        autocmd! BufRead,BufNewFile *.usd set filetype=usd
        autocmd! BufRead,BufNewFile *.usda set filetype=usda
    augroup END
    " SessionLoadPost
    "augroup tdvimSessionLoadPost
    "augroup END

    " CursorHold
    "augroup tdvimCursorHold
        "autocmd! CursorHold * ++nested call utils#UpdateDevIconFileType()
        "autocmd! CursorHold leaderf ++nested normal <C-I>
    "augroup END

else
    set autoindent		" always set autoindenting on
endif " has("autocmd")

" }}}


" Always run mswin at the end {{{
" Load more conventional editors options, MSWin mode:
source $VIMRUNTIME/mswin.vim
" Fix mswin, it enters in select mode rather than visual.
set selectmode=""
" }}}

" XXX: Mmmm this is provably controversial
" Automatically change directory
set autochdir

" TODO:
" Project Mode {{{
" If vim is opened in a directory then enable some special settings to
" work in a project, assuming the current folder is the project root
" TODO:
" Disable autochdir
" Try to load project.vim if exist
" Create/Update tags file
" Try to open session if exists
" Set title to put project name
" Set wildoptions+=tagfile
" Set wildoptions+=fuzzy

" }}}

" Load user settings {{{
if has('unix')
  " unix-like platform (including Cygwin)
  if filereadable($HOME . "/myvimrc")
    source $HOME/myvimrc
  elseif filereadable($HOME . "/.myvimrc")
    source $HOME/.myvimrc
  elseif filereadable($HOME . "/_myvimrc")
    source $HOME/_myvimrc
  else
    " Do nothing
  endif
else
  " probably Windows
  if has("win32")
    if filereadable($HOME . "/myvimrc")
      source $HOME/myvimrc
    elseif filereadable($HOME . "/_myvimrc")
      source $HOME/_myvimrc
    elseif filereadable($HOME . "/.myvimrc")
      source $HOME/.myvimrc
    else
      " Do nothing
    endif
  endif
endif

"}}}

" TDVim version
let $TDVIMVERSION="0.4"

" vim: ts=8 ft=vim nowrap fdm=marker
