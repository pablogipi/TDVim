"
" Main Vim setup in single file without any external plugin dependencies
"
" Mantainer:	Pablo Gimenez <pablogipi@gmail.com>
" Last change:	2009 Dec 9
"
"

" Sections:
" - Detect Project/Dev Mode
" - Functions
" - Init settings
" - Terminal Settings
" - Search settings
" - Keyboard mappings
" - Interface settings
" - Edit options and Language specific options
" - Diff mode specific options
" - Autocommands
" - Custom commands
" - Project Mode
" - Global variables
"

" Project/Dev Mode {{{
let g:tdvim_dev_mode = 0

function! s:DetectDevMode()
    if isdirectory(argv(0))
        return 1
    else
        return 0
    endif
endfunction

if s:DetectDevMode()
    let g:tdvim_dev_mode = 1
endif
" }}}


" Functions {{{

" GetOS {{{2
" Get host OS: 
" 0: Unkmown OS
" 1: UNIX (usually Linux), no Mac
" 2: MacOS
" 3: Windows
function! s:GetOS()
    if has("win32") || has("win64") || has("win32unix")
        return 3
    elseif has("mac") || has("macunix")
        return 2
    elseif has("unix")
        return 1
    else
        return 0
    endif
endf
" }}}

" getWinInfo {{{2
" winid: id of the window, if not passed then current window will be used
"function! s:getWinInfo( winid=-1 )
function! s:getWinInfo( winid )
    let curwin = a:winid
    if curwin == -1
        let curwin = winnr()
    endif
    let wininfos = getwininfo()
    for idx in range( len( wininfos ) )
        let wininfo = wininfos[ idx ]
        if wininfo['winnr'] == curwin
            return wininfo
        endif
    endfor
    return {}
endfunction
" }}}

" NeatFoldText {{{2
" Improve text for folding line
function! s:NeatFoldText()
    let line = ' ' . substitute(getline(v:foldstart), '^\s*"\?\s*\|\s*"\?\s*{{' . '{\d*\s*', '', 'g') . ' '
    let lines_count = v:foldend - v:foldstart + 1
    let lines_count_text = '| ' . printf("%10s", lines_count . ' lines') . ' |'
    let foldchar = matchstr(&fillchars, 'fold:\zs.')
    let foldtextstart = strpart('+' . repeat(foldchar, v:foldlevel*2) . line, 0, (winwidth(0)*2)/3)
    let foldtextend = lines_count_text . repeat(foldchar, 8)
    let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
    return foldtextstart . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
endfunction
" }}}

" SetLocalPath {{{2
" Set the local path for the current buffer to the folder that contains the
" loaded file
function! s:SetLocalPath ()
    " If in dev mode dont change location automatically
    if g:tdvim_dev_mode && s:has_git && has('b:tdvim_proj_root')
        " Rooter, set buffer location to project roo in dev mode
        silent! exe 'lcd ' . b:tdvim_proj_root
    else
        " Current basename for the buffer
        let baseName = expand("%:p:h")
        if isdirectory(baseName)
            silent! exe 'lcd ' . fnameescape(baseName)
        endif
    endif
endfunction
" }}}

" SetupAuxBuffer {{{2
" Setup common settings for auxiliary windows like quickfix and preview
" Setups done:
" Set q and <Esc> as keymaps to close the window
function! s:SetupAuxBuffer( )
     "echomsg "Calling setup for qickfix buffer"
    " Aux buffers local maps
    " Close window with Esc or q
    map <silent> <buffer> <Esc> :bdelete <bar> wincmd p<CR>
    map <silent> <buffer> q :bdelete <bar> wincmd p<CR>

    "For quickfix and location list disable buffer in buffers list
    if 'quickfix' ==# &buftype
        let wininfo = s:getWinInfo( -1 )
        " Move quickfix to the bottom
        if wininfo['quickfix'] && !wininfo['loclist']
            wincmd J
        endif
        setlocal nobuflisted
        setlocal cursorline
    endif

endfunction
" }}}

" CloseAllBuffersByType {{{2
" Close all buffers for a given buffertype, filetype or syntax
" @param type type to delete
" @param mode delete mode: 0- buftype, 1- filtetype, 2- syntax
function! TDVimCloseAllBuffersByType( type, mode )
  " Save current window number to revert.
  let sel_winnr = winnr()
  let nwin = 1
  for nbuf in range(1, bufnr('$'))
      let to_delete = 0
      "echo "Buffer number: " . nbuf
      "echo "Buffer :" . bufname( nbuf )
      "echo "Buffertype :" .getbufvar(nbuf, '&buffertype') 
      "echo "Filetype :" .getbufvar(nbuf, '&filetype') 
      "echo "Syntax :" .getbufvar(nbuf, '&syntax') 
      if a:mode == 0 && getbufvar(nbuf, '&buftype') ==# a:type
          let to_delete = 1
      elseif a:mode == 1 && getbufvar(nbuf, '&filetype') ==# a:type
          "echo "DETECTED!!!"
          let to_delete = 1
      elseif a:mode == 2 && getbufvar(nbuf, '&syntax') ==# a:type
          let to_delete = 1
      endif
      "echo "Need to delete: " . to_delete
      if to_delete == 1
          "bdelete! bufname( nbuf ) 
          "silent! exe 'lcd ' . fnameescape(baseName)
          exe 'bwipeout! ' . bufname( nbuf ) 
      endif
  endfor


endfunction
" }}}


" CloseAllWindowsByType {{{2
" Close all windows for a given buffertype
function! TDVimCloseAllWindowsByType( buffertype )
    " For preview window just run pclose and exit:
    if "preview" ==# a:buffertype
        pclose
        return
    endif
  " Save current window number to revert.
  let sel_winnr = winnr()
  let nwin = 1
  while 1
      let nbuf = winbufnr(nwin)
      " After all window processed, finish.
      if nbuf == -1
          break
      endif
      " Close window if its buftype is same as buffertype argument.  If not help, go to next window.
      if getbufvar(nbuf, '&buftype') ==# a:buffertype
          " Correct saved window number if younger window will be closed.
          if sel_winnr > nbuf
              let sel_winnr = sel_winnr - 1
          endif
          execute nwin.'wincmd w'
          " If there is only one help window, quit.
          if nwin == 1 && winbufnr(2) == -1
              quit!
          else
              close!
          endif
      else
          let nwin = nwin + 1
      endif
  endwhile
  " Revert selected window.
  "execute save_winnr.'wincmd w' , silent!
  silent! sel_winnr.'wincmd w'
endfunction
" }}}


" JumpToWindowsByType {{{2
" Given a buffer type, jump to it.
" Used to jump to quickfix, preview or location windows
" Check against:
" - Buffer type
" - File Type
" - Preview Window
function! TDVimJumpToWindowsByType ( buffertype )
  " Save current window number to revert.
  let save_winnr = winnr()
  let nwin = 1
  while 1
      let nbuf = winbufnr(nwin)
      " After all window processed, finish.
      if nbuf == -1
          break
      endif
      " Close window if its buftype is same as buffertype argument.  If not help, go to next window.
      "echo "Look into window " . nwin . ", buffer type: " . getbufvar(nbuf, '&buftype')
      let cond1 = getbufvar(nbuf, '&buftype') ==# a:buffertype
      let cond2 = getbufvar(nbuf, '&filetype') ==# a:buffertype
      let cond3 = "preview" ==# a:buffertype ? getwinvar(nwin, '&previewwindow') : 0
      " quickfix buffer type is a special case, it can be quickfix or location
      " list
      if "quickfix" ==# a:buffertype || "location" ==# a:buffertype
          " Get current window info
          let wininfo = s:getWinInfo( nwin )
          let islocwin = wininfo['loclist']
          let cond1 = 0
          if "quickfix" ==# a:buffertype && wininfo['quickfix'] && !wininfo['loclist']
              let cond1 = 1
          endif
          if "location" ==# a:buffertype && wininfo['quickfix'] && wininfo['loclist']
              let cond1 = 1
          endif
          "echomsg "Type: " . a:buffertype . " ,Condition: " . cond1
      endif
      if "qf" ==# a:buffertype
          " Get current window info
          let wininfo = s:getWinInfo( nwin )
          let cond2 = wininfo['quickfix'] && !wininfo['loclist']
      endif
      if cond1 || cond2 || cond3
          "echomsg "Correct!, jump to window " . nwin
          " Correct saved window number if younger window will be closed.
          if save_winnr > nbuf
              let save_winnr = save_winnr - 1
          endif
          execute nwin.'wincmd w'
          break
      "elseif cond3
          "" For preview window
          "let buffervars = getbufvar(nbuf, '&')
          "echo Vars:
          "echo buffervars
          "let cond = getwinvar(nwin, '&previewwindow')
          "echo "Window condition: " . cond
          "pclose
          "break
      else
          let nwin = nwin + 1
      endif
  endwhile
endfunction
" }}}

" OnlyReadSetup {{{2
" Setup only read buffers
" This is mainly used to offer a better experience for only read.
" Usually used when vim is started as view
" Setup actions
" - Map q to close the buffer, in most cases this will close vim
" Usage: call this using a BufEnter autocommand
function! s:OnlyReadSetup()
    if &ro
        " Only work on read only buffers
        nmap q :cq<CR>
        return
    endif
endfunction
" }}}


" PreviewWindowSetup {{{2
" Setup preview window depending based on previous window type.
" This is mainly used to offer a better preview for tags and other
" development help.
" Usage: call this using a BufWinEnter autocommand
function! s:PreviewWindowSetup()
    if &previewwindow			" if we really are at the preview window
        "echomsg "In Preview window!!"
        if &filetype == ""
            " Tags preview
            set filetype=passwd 
        else
            " Preview jump to tag
                                " silent! foldopen!   " Disable folds
            set nofoldenable
            setlocal cursorline " Highlight current line
            set number          " Set line numbers
            set ro              " Force Read-Only
        endif
        " Preview buffers local maps
        map <silent> <buffer> <Esc> :bdelete <bar> wincmd p<CR>
        map <silent> <buffer> q :bdelete <bar> wincmd p<CR>
        " Move preview window to the very bottom
        wincmd J
        " But keep Quickfix window at the bottom :)
        call TDVimJumpToWindowsByType( 'quickfix' )
        wincmd J
        " Go back to preview
        wincmd P
    endif
endfunction
" }}}

" LeavePreviewWindowSetup {{{2
" Setup preview window when leaving it
" Usage: call this using a BufWinLeave autocommand
 function! s:LeavePreviewWindowSetup ()
    if &previewwindow			" if we really are at the preview window
        " Restore buffer editable
        set noro
    endif
 endfunction
"
" }}}

" TabAutocompleteWrapper {{{2
" Function to call to Autocomplete when pressing TAB
" Or insert a TAB if there is nothing in front of the cursor
" From: https://stackoverflow.com/questions/2055417/mapping-tab-to-omicompletion-in-gvim 
function! TDVimTabAutocompleteWrapper( direction)
  " Make TAB working in popup menu
  if pumvisible()
    if "backward" == a:direction
      return "\<C-P>"
    else
      return "\<C-N>"
    endif
  endif
  " Pass a normal TAB if there is no character in front.
  " Use autocomplete if there is something in front of the cursor
  let char_before = col('.') - 1
  if !char_before || getline('.')[char_before - 1] !~ '\k'
    "if "backward" == a:direction
    "return "\<BS>"
    "else
    "return "\<tab>"
    "endif
    return "\<tab>"
  elseif "backward" == a:direction
    return "\<c-p>"
  else
    return "\<c-n>"
  endif
endfunction
" }}}

" CreateOrJumpToTerminal {{{2
" Try to jump to an existing terminal, if succesful then restore window size
" If not then create a new terminal
function! TDVimCreateOrJumpToTerminal ( )
  call TDVimJumpToWindowsByType("terminal")
  if &buftype == "terminal"
    wincmd =
    " echo "In terminal"
  else
    " wincmd b | botright terminal<CR>
    botright terminal
  endif
  " wincmd J
endfunction
" }}}


" ClosePreviousWindow {{{2
" Close previous window
function! TDVimClosePreviousWindow()
    let prevwindow = winnr('#')
    if prevwindow > 0
        execute prevwindow . 'wincmd c'
    endif
endfunction
" }}}

" SetupNERDTreeBuffer {{{2
" Functiom to do some custom setups in a NERDtree buffer when Syntax event
" is triggered usinh autocommands.
" Close NERDtree window using - or Esc.
function! s:SetupNERDTreeBuffer(  )
    " Check we are actually in a NERDTree buffer
    if &syntax !~ "nerdtree"
        echoerr "We are NOT in a NERDtree buffer!!!: " . curbuf
        return
    endif
    "echomsg "We are in a NERDtree buffer!!!"
    nmap <buffer> -        :call nerdtree#ui_glue#invokeKeyMap("q")<CR>
    nmap <buffer> <silent> <Esc> :call nerdtree#ui_glue#invokeKeyMap("q")<CR>
endfunction
" }}}

" UpdateCurrentGitBranch {{{2
" Update current git branch from buffer in window. This function will use gitbranch#name() 
" The intention is to call this function from the CursorHold autocommand.
" This way we can update curent branch only when the cursor stops.
" The function will set the window variable: w:currentgitbranch .
" Only update if g:tdvim_update_git_branch is set
function! TDVimUpdateCurrentGitBranch()
  if exists('*gitbranch#name')
      let w:currentgitbranch = gitbranch#name()
  endif
endfunction
"}}}

" UpdateDevIconFileType {{{2
" Update current Dev Icon for buffer in window. This function use WebDevIconsGetFileTypeSymbol()
" The intention is to call this function from the CursorHold autocommand.
" The function will set the window variable: w:currentdeviconfiletype .
function! TDVimUpdateDevIconFileType()
    if exists('*WebDevIconsGetFileTypeSymbol')
        let w:currentdeviconfiletype = WebDevIconsGetFileTypeSymbol()
    endif
endfunction
"}}}

" Lightline Functions {{{2

" LightlineMode {{{3
" Custom version of original lightline mode function to return
" mode string.
" Customizations:
" - Support preview window
let s:LightLineModeMap = { 'n': 'NORMAL', 'i': 'INSERT', 'R': 'REPLACE', 'v': 'VISUAL', 'V': 'V-LINE', "\<C-v>": 'V-BLOCK',
        \     'c': 'COMMAND', 's': 'SELECT', 'S': 'S-LINE', "\<C-s>": 'S-BLOCK', 't': 'TERMINAL'
        \}
function! TDVimLightlineMode() abort
    " Get current window info
    let wininfo = s:getWinInfo(-1)

    if &previewwindow
        return 'PREVIEW'
    elseif &filetype == "ctrlp"
        return 'CTRLP'
    elseif &filetype == "help"
        return 'HELP'
    elseif &filetype == "qf"
        if wininfo['loclist'] 
            "let parentwinid = getloclist( winnr(), {'filewinid': -1} )['filewinid']
            "let parentwinname = bufname( winbufnr( parentwinid ) )
            "return 'LOCATIONLIST - ' . parentwinname
            return 'LOCATIONLIST'
        else
            return 'QUICKFIX'
        endif
    elseif &filetype == "tagbar"
        return 'SYMBOLS'
    elseif &filetype == "nerdtree"
        return 'EXPLORER'
    elseif &filetype == "fugitive"
        return 'GIT'
    else
        return get(s:LightLineModeMap, mode(), '')
    endif
endfunction
" }}}

" LightlineFilename {{{3
" Custom version of original lightline filename function to return
" filename string.
" Customizations:
" - return empty string for those filetypes where filename is not needed and
"   mode is used instead.
" - Fow Quickfix windows return empty name, for location windows return name of
"   file associated to parent window
function! TDVimLightlineFilename() abort
    " Get current window info
    let wininfo = s:getWinInfo(-1)

    if &filetype == "help" || &filetype == "ctrlp" || &filetype == "tagbar" || &filetype == "nerdtree"
        return ''
    endif
    " For quickfix windows:
    "
    if &filetype == "qf"
        if wininfo['loclist'] 
            let parentwinid = getloclist( winnr(), {'filewinid': -1} )['filewinid']
            let parentwinname = bufname( winbufnr( parentwinid ) )
            return parentwinname
        else
            return ''
        endif
    endif
    return expand('%:t') !=# '' ? expand('%:t') : '[No Name]'
endfunction
" }}}

" LightlineInactiveMode {{{3
" Return PREVIEW string or nothing, used in lightline for inactive windows
function! TDVimLightlineInactiveMode() abort
    " Get current window info
    let wininfo = s:getWinInfo(-1)

    if &previewwindow
        return 'PREVIEW'
    elseif &filetype == "ctrlp"
        return 'CTRLP'
    elseif &filetype == "help"
        return 'HELP'
    elseif &filetype == "qf"
        if wininfo['loclist'] 
            "let parentwinid = getloclist( winnr(), {'filewinid': -1} )['filewinid']
            "let parentwinname = bufname( winbufnr( parentwinid ) )
            "return 'LOCATIONLIST - ' . parentwinname
            return 'LOCATIONLIST'
        else
            return 'QUICKFIX'
        endif
    elseif &filetype == "tagbar"
        return 'SYMBOLS'
    elseif &filetype == "nerdtree"
        return 'EXPLORER'
    else
        return ''
    endif
endfunction
" }}}

" LightLine utility functions {{{3
function! TDVimLightlineReadonly()
    if &filetype == "help" || &previewwindow || &filetype == "ctrlp" || &filetype == "qf" || &filetype == "tagbar" || &filetype == "nerdtree" || &buftype ==# "terminal"
        return ''
    else
      if  exists('g:GuiLoaded') || has('gui_running')
        return &readonly ? '' : ''
      else
        return &readonly ? 'RO' : ''
      endif
    endif
endfunction

function! TDVimLightlineModified()
    if &filetype == "help" || &previewwindow || &filetype == "ctrlp" || &filetype == "qf" || &filetype == "tagbar" || &filetype == "nerdtree" || &buftype ==# "terminal"
        return ''
    else
      if  exists('g:GuiLoaded') || has('gui_running')
        " return &modified ? '✗' : '✓'
        return &modified ? '✎' : '✓'
      else
        return &modified ? 'x' : 'o'
      endif
    endif
endfunction

function! TDVimLightlineDeviconsFiletype()
    "return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype . ' ' . WebDevIconsGetFileTypeSymbol() : 'no ft') : ''
    if &filetype == "help"
        return 'ﬁ'
    elseif &filetype == "qf"
        return 'ί'
    else
        "return winwidth(0) > 70 ? (strlen(&filetype) ? WebDevIconsGetFileTypeSymbol() : '') : ''
        if exists('w:currentdeviconfiletype')
            return winwidth(0) > 70 ? (strlen(&filetype) ? w:currentdeviconfiletype : '') : ''
        endif
    endif
endfunction

function! TDVimLightlineDeviconsFileformat()
  return winwidth(0) > 70 ? (&fileformat . ' ' . WebDevIconsGetFileFormatSymbol()) : ''
endfunction

function! TDVimLightlineGit()
  if &filetype == "help" || &previewwindow || &filetype == "ctrlp" || &filetype == "qf" || &filetype == "tagbar" || &filetype == "nerdtree" || &buftype ==# "terminal"
      return ''
  elseif winwidth(0) < 100
      return ''
  elseif exists('w:currentgitbranch')
    if  exists('g:GuiLoaded') || has('gui_running')
      return w:currentgitbranch !=# '' ? ''.w:currentgitbranch : ''
    else
      return w:currentgitbranch !=# '' ? '|/'.w:currentgitbranch : ''
    endif
  endif
  return '-'
endfunction

function! TDVimGitHunksummary()
    let [a,m,r] = GitGutterGetHunkSummary()
    return printf('+%d ~%d -%d', a, m, r)
endfunction

" LightlineExtraInfo
" Return some extra information at the center of lightline
" - For programming file types return tag for current function
" - For Quickfix and Location list windows return command used to generated the
"   window entries
function! TDVimLightlineExtraInfo() abort
  " Only add extra info for wide enough windows
  if winwidth(0) < 100
      return ""
  endif

  " Get current window info
  let wininfo = s:getWinInfo(-1)

  " Quickfix and Location List windows
  if &filetype == "qf"
      if exists("w:quickfix_title")
          return wininfo['variables']['quickfix_title']
      endif
  endif

  " Programing 
  " Using w:curenttag set by UpdateCurrentTag using CursorHold autocmd. This fixes the lagging due to calling tagbar#currenttag in every redraw
" if exists("w:currenttag")
"     let l:tag = w:currenttag
"     if len(w:currenttag) > winwidth(0)
"          " Give 75 characters margin to the left in order to [reserver the
"          " left part of the status line
"          let l:tag = l:tag[0:winwidth(0) - 75 ]
"          let l:tag .= " ..."
"      endif
"      "return w:currenttag
"      "return string(winwidth(0))
"      return l:tag
"  endif

  return ""
endfunction
" }}}


" Lightline Functions}}}

" SetFancyUI {{{2
" Set fancy unicode symbols for UI. Mostly lightline.
function! s:SetFancyUI()
    " fancy UI using UTF and fancy icons

    if  exists('g:GuiLoaded') || has('gui_running')
        if g:tdvim_dev_mode && s:has_git
            let g:lightline.active = {
                        \ 'left': [ [ 'mode', 'paste' ], [ 'readonly', 'filetypeicon', 'filename', 'modifiedicon', 'githunksummary' ], [ 'extrainfo', 'tagsgen' ] ],
                        \ 'right': [ [ 'lineinfo' ], [ 'fileformat', 'percent' ], [ 'git' ] ]
                        \   }
        else
            let g:lightline.active = {
                        \ 'left': [ [ 'mode', 'paste' ], [ 'readonly', 'filetypeicon', 'filename', 'modifiedicon' ], [ 'extrainfo', 'tagsgen' ] ],
                        \ 'right': [ [ 'lineinfo' ], [ 'fileformat', 'percent' ] ]
                        \   }
        endif

        let g:lightline.component.lineinfo = '▤ %3l:%-2v'
        let g:lightline.separator = { 'left': '', 'right': '' }
        let g:lightline.subseparator = { 'left': '', 'right': '' }    
        let g:lightline#bufferline#unicode_symbols = 1
        let g:lightline#bufferline#enable_devicons = 1
    else
        let g:lightline.component.lineinfo = '%3l:%-2v'
    endif

    " if exists('g:loaded_lightline') && exists('g:lightline')

    " if has_key( g:lightline, 'component' )
    " let g:lightline.component.lineinfo = '▤ %3l:%-2v'
    " else
    " let g:lightline.component = {}
    " let g:lightline.component.lineinfo = '▤ %3l:%-2v'
    " endif
    " :au! CursorHold * ++nested call TDVimUpdateCurrentGitBranch()
    " let g:lightline.separator = { 'left': '', 'right': '' }
    " let g:lightline.subseparator = { 'left': '', 'right': '' }    
    " endif
    if exists('g:loaded_lightline_buffer')
        "let g:lightline_buffer_logo = "\u233e"
        let g:lightline_buffer_logo                     = "》"
        let g:lightline_buffer_readonly_icon            = ''
        let g:lightline_buffer_modified_icon            = '✗'
        let g:lightline_buffer_git_icon                 = ' '
        let g:lightline_buffer_ellipsis_icon            = '..'
        let g:lightline_buffer_expand_left_icon         = "\u25c4"
        let g:lightline_buffer_expand_right_icon        = "\u25ba"
        let g:lightline_buffer_active_buffer_left_icon  = '▌'
        let g:lightline_buffer_active_buffer_right_icon = '▐'
        "let g:lightline_buffer_separator_icon = "\u25b9"
        let g:lightline_buffer_separator_icon           = "╱"
    endif
    " Force lightline update
    call lightline#disable()
    call lightline#enable()
    call lightline#bufferline#reload()
endfunction
"}}}


" Session functions {{{2
 " Save session
fu! TDVimSaveSess()
    " Only in project mode
    if !g:tdvim_dev_mode || !exists('g:tdvim_proj_root')
        return
    endif
    let sessionfile = g:tdvim_proj_root_config . '/session.vim'
    call TDVimCloseAllBuffersByType( 'nerdtree', 1)
    execute 'mksession! ' . sessionfile 
    echomsg "Session saved in: " . sessionfile
endfunction

" Restore session {{{3
fu! TDVimRestoreSess()
    " Only in project mode
    if !g:tdvim_dev_mode || !exists('g:tdvim_proj_root')
        return
    endif
    let sessionfile = g:tdvim_proj_root_config . '/session.vim'
    echomsg "Restoring vim session: " . sessionfile
    if filereadable(sessionfile)
        "echomsg "Source session ..."
        execute 'source ' . sessionfile
        " Delete all buffers that are a folder or its's name starts with
        " NERD_tree. These are usually the NERD Tree buffers and we dont want
        " them on load
        for nbuf in range(1, bufnr('$'))
            let to_delete = 0
            "echomsg "Buffer number: " . nbuf
            let buffer_name = bufname( nbuf )
            "echomsg "Buffer :" . buffer_name
            if isdirectory(buffer_name)
                let to_delete = 1
            elseif match(buffer_name, "NERD_tree") == 0
                let to_delete = 1
            endif
            if to_delete == 1
                "echomsg("Buffer deleted")
                exe "bdelete! " . nbuf
            endif
        endfor
    else
        echomsg "Can't restore project session from: " . sessionfile
    endif
endfunction
" }}}

" }}}



" Functions }}}

"
" Init settings {{{
"
" When started as "evim", evim.vim will already have done these settings.
if v:progname =~? "evim"
    finish
endif


" Use Vim settings, rather then Vi settings (much better!).
" This must be first, because it changes other options as a side effect.
set nocompatible
" Allow backspacing over everything in insert mode
set backspace=indent,eol,start

" Backup and swap files
" Do not keep a backup file for VMS
if has("vms")
    set nobackup
else
    set backup                               " keep a backup file
endif
let vimbackuppath = $HOME . '/.vim/tmp'
if has('win32') || has('win64')
    "Windows
    let vimbackuppath = $HOME . '/vimfiles/tmp'
endif
let &backupdir = vimbackuppath . '//,.'
let &directory = vimbackuppath . '//,.'
silent call mkdir (vimbackuppath , 'p')

" Set viminfo. Mainly set history limits
" File history: 25
" Maximum lines per registry: 100
" Maximum sze of a register: 10KB
" Disable hlsearch
set viminfo='25,<100,s10,h
if s:GetOS() == 3
    "Windows
    set viminfo+=rA:
    set viminfo+=rB:
endif


" Check terminals colors, if is not a 256 color terminal make a warning
if !has('gui_running') && &t_Co < 256
  silent echomsg "Current terminal doesn't support 256 colors. Some colors and the status line won't look correctly"
else
  " Gives Vim access to a broader range of colours
  set termguicolors
endif


" Always run mswin at the end
" Load more conventional editors options, MSWin mode:
source $VIMRUNTIME/mswin.vim
" Fix mswin, it enters in select mode rather than visual.
set selectmode=""
" Auto change directory
set autochdir
" Use OS clipboard:
set clipboard^=unnamed,unnamedplus

" Detect some commands availability in the system {{{2

" Detect FZF
let s:has_fzf = 0
if  executable('fzf')
    let s:has_fzf = 1
endif
" Detect RipGrep
let s:has_rg = 0
if  executable('rg')
    let s:has_rg = 1
endif
" Detect fd
let s:has_fd = 0
if  executable('fd')
    let s:has_fd = 1
endif
" Detect Git
let s:has_git = 0
if  executable('git')
    let s:has_git = 1
endif
" Detect Bash
let s:has_bash = 0
if  executable('bash')
    let s:has_bash = 1
endif
" Detect bat
let s:has_bat = 0
if  executable('bat')
    let s:has_bat = 1
endif
" Detect cat
let s:has_cat = 0
if  executable('cat')
    let s:has_cat = 1
endif
" }}}


" Init Setting }}}

"
" Sessions {{{
" Options for what to save in the sessions file:
let &sessionoptions='buffers,curdir,folds,resize,winsize'
"let &sessionoptions-='help'
"let &sessionoptions+='resize'
" View, restore file state options:
let &viewoptions='cursor,folds,slash,unix'

" Sessions }}}

" Terminal settings {{{
set ttyfast
" set term gui colors (most terminals support this)
set termguicolors

" Terminal settings }}}

" Edit options and Language specific options {{{
"

" Set buffers to be hidden for easy switching
set hidden
" Consider windows in other tabs when opening a buffer
set switchbuf=usetab

" Default editing setup:
" Settings common for all file types:

" Tabs width
let &shiftwidth  = 4
let &softtabstop = 4
let &shiftwidth  = 4
" Size for the TAB
let &tabstop=&shiftwidth
set expandtab
" Always round indent to shiftwidth
set shiftround
" Line numbering for all file formats:
set number
" Better folding:
set foldtext=s:NeatFoldText()

set whichwrap+=<,>,[,],h,l
set iskeyword+=-
set formatoptions-=cro

" Search settings {{{2
" Switch on highlighting the last used search pattern if colors  are supported
if &t_Co > 2 || has("gui_running")
    set hlsearch
endif

" Activate showmatch
set showmatch
" Do incremental searching
set incsearch
" Switch on search pattern highlighting.
set hlsearch
" Search case mode:
set ignorecase
set smartcase
" make indenting smarter again
set smartindent
" Global search by default
set gdefault
" Better grep
if s:has_rg
  set grepprg=rg\ --vimgrep
  set grepformat=%f:%l:%c:%m
elseif executable("ag")
  set grepprg=ag\ --vimgrep\ --ignore\ *~\ --ignore\ *.swp\ --ignore\ *.diff\ --ignore\ tags\ --ignore\ *.tags
  set grepformat=%f:%l:%c:%m
endif

" }}}

" Syntax highlighting {{{2
" Switch syntax highlighting on, when the terminal has colors
if &t_Co > 2 || has("gui_running")
    syntax on
endif
set nocursorcolumn
" set nocursorline
set norelativenumber
syntax sync minlines=256
" }}}

" }}}

" Interface settings {{{
"
"Encoding {{{2
" UTF-8 encoding has been disabled due to several compatibility problems
" Spacially with terminals.
if has("multi_byte")
    if &termencoding == ""
        let &termencoding = &encoding
    endif
    set encoding=utf-8
    "setglobal fileencoding=utf-8 bomb
    setglobal fileencoding=utf-8
    set fileencodings=ucs-bom,utf-8,latin1
endif
"}}}

" In many terminal emulators the mouse works just fine, thus enable it.
set mouse=a

" Color Theme
" Leave this for the user settings, use default
colorscheme desert

" Preview Window Height
set previewheight=8
" pop up menu height
set pumheight=10
" set number column width to 4 {default 4}
set numberwidth=4
" always show the sign column, otherwise it would shift the text each time
set signcolumn=yes

" Folding options: {{{2
" Default folding method id indent
set foldmethod=indent
" Folds margin width
set foldcolumn=2
" Minimum lines in a  fold to consider it a a proper fold
set foldminlines=3
" Fold starting level, set to 1 to have only level 1 folds ready
set foldlevelstart=-1
" Max nested level
let &foldnestmax=3
" }}}

" Tabs label format:
"set guitablabel=%{utils#GuiTabLabel()}
" Always show tabs
set showtabline=2


" Status Line {{{2
" Always show status line:
set laststatus=2
" Defaul status line
set statusline=%-f%m%r%h%w%q\ %y\ %=[POS=%l,%v][%p%%]
" Disable show mode, not needed when using lighline or any other status line
" plugin
set noshowmode


" }}}

" Preview window {{{2
set pvh=5
" }}}

" Invisible character {{{2
"set listchars=tab:▸\ ,eol:¬
set listchars=tab:>-,eol:¬,space:.,trail:.
" }}}

" Lines wraping and formatting {{{2
set wrap
set textwidth=79
set formatoptions=qrn1
" }}}


" FoldDigest {{{2
if exists("$FOLDDIGEST_POS")
    let g:FoldDigest_Pos=$FOLDDIGEST_POS
else
    let g:FoldDigest_Pos="right"
endif

" }}}

" Netrw {{{2
let g:netrw_sort_sequence = '[\/]$,*'
"let g:netrw_browse_split  = 4
let g:netrw_banner=0        " disable annoying banner
let g:netrw_browse_split=0  " open in prior window
let g:netrw_altv=1          " open splits to the right
let g:netrw_liststyle=3     " tree view
let g:netrw_list_hide=netrw_gitignore#Hide()
let g:netrw_list_hide.=',\(^\|\s\s\)\zs\.\S\+'
let g:netrw_sizestyle="H"   " Human readable sizes
" }}}

" Command line {{{2
set history=50                           " keep 50 lines of command line history
" Command line height
set cmdheight=2

" Command Line Complete Menu
set wildmenu
set wildmode=list:longest,full            " Complete the next full match
" Ignores patterns in autocomplete
if s:GetOS() == 1
    "Linux
    set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*.swp,*.bak,*~,*.o,*.obj,*.pyc,tags,cscope*
elseif s:GetOS() == 2
    "Mac
    set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*.swp,*.bak,*~,*.o,*.obj,*.pyc,tags,cscope*
elseif s:GetOS() == 3
    "Windows
    set wildignore+=*\\.git\\*,*\\.hg\\*,*\\.svn\\*,*.swp,*.bak,*~,*.o,*.obj,*.pyc,tags,cscope*
endif
" Search down into subfolders
" Provides tab-completion for all file-related tasks
set path+=**
" }}}

"""""""""""""""""""""""""""
""""""""""""""""""""""""""" }}}

" GUI {{{
if has("gui_running")
    set mousehide		" Hide the mouse when typing text
    set mousemodel=popup	" Enable popup menu using mouse

    " Set GUI font and general options
    if has('gui_gtk2') || has('gui_gtk3')
        set gfn=DejaVu\ Sans\ Mono\ 10
        "set guioptions = "agimrLtT"
        set guioptions += "aAgimrLt"
    elseif has('gui_photon')
        set gfn=DejaVu\ Sans\ Mono:s10
    elseif has('gui_kde')
        " the obsolete kvim
        " just make sure it works correctly if it hits our vimrc
        set gfn=DejaVu\ Sans\ Mono/10/-1/5/50/0/0/0/1/0
    elseif has('x11')
        " I'm guessing the following (other-X11 including GTK1)
        " please check, and correct if necessary.
        " On GTK1 (and maybe some others) you can use :set gfn=*
        " Replace by asterisks like here
        " to make it a little more general:
        set gfn=-*-dejavu-medium-r-normal-*-*-10-*-*-m-*-*
        " add another elseif here
        " if you want DejaVu on mac-without-x11
    elseif has("gui_macvim") || has("gui_mac")
        set gfn=DejaVu\ Sans\ Mono:h13
    elseif has("win32")
        set guioptions+="gmrLtT"
        set guifont=Consolas:h11:cANSI:qDRAFT
    else
        " system not detected
    endif

    " Better updatetime for GUI
    set updatetime=1000


endif
" }}}

" Custom commands {{{
" Create Tags file in current location
command! TDVimMakeTags !ctags -R  --sort=1 --c++-kinds=+p --fields=+iaS --extras=+q --exclude='.git' --exclude='.svn' --exclude='*.so' --exclude='__pycache__' --exclude='*.pyc'  
" Jump to existing terminal and restore or create a new terminal
command! TDVimOpenTerminal call TDVimCreateOrJumpToTerminal()
" Run grep, allow user to mpdify initial pattern and then open quickfix window wit results
command! -nargs=+ TDvimGrep execute 'silent grep! <args>' | copen
" }}}

" Keyboard mappings {{{
" Leader key
"let mapleader = ","
"let mapleader = "`"
let mapleader = "\<Space>"
let maplocalleader = ","

" Modes
"   normal_mode = "n",
"   insert_mode = "i",
"   visual_mode = "v",
"   visual_block_mode = "x",
"   term_mode = "t",
"   command_mode = "c",
"
"
" Modes {{{2
" Operations to change between modes

" Command Line Mode - F2
nnoremap  <F2>              :
xnoremap  <F2>              :
inoremap  <F2>              <ESC>:
tnoremap <F2>               <C-w>:

" Press jk fast exit Insert and enter Normal mode
imap  <silent> jk              <ESC>

" }}}

" Help {{{2
if s:has_fzf
    nnoremap  <S-F1>             :Helptags<CR> 
    xnoremap  <S-F1>             :Helptags<CR> 
    inoremap  <S-F1>             <C-O>:Helptags<CR> 
else
    nnoremap  <S-F1>             :h <C-r><C-w><CR> 
    xnoremap  <S-F1>             :h <C-r><C-w><CR> 
    inoremap  <S-F1>             <C-O>:h <C-r><Cew><CR> 
endif
" }}}

" Main Operations {{{2
" Main operations like open, save, new, quit, etc ...
" Open Files in current location - S-F3, <leader>o
if s:has_fzf
    nnoremap   <S-F3>   :Files<CR>
    vnoremap   <S-F3>   :Files<CR>
    inoremap   <S-F3>   <ESC>:Files<CR>
else
    nnoremap   <S-F3>   :find<space>
    vnoremap   <S-F3>   :find<space>
    inoremap   <S-F3>   <ESC>:find<space>
endif
" Open Recent Files - C-S-F3
if s:has_fzf
    nnoremap   <C-S-F3>   :History<CR>
    vnoremap   <C-S-F3>   :History<CR>
    inoremap   <C-S-F3>   <ESC>:History<CR>
else
    nnoremap   <C-S-F3>   :browse oldfiles<CR>
    vnoremap   <C-S-F3>   :browse oldfiles<CR>
    inoremap   <C-S-F3>   <ESC>:browse oldfiles<CR>
endif
" Save - <leader>w
nnoremap   <leader>w    :w<CR>
" Save All - <leader>wa
nnoremap   <leader>wa   :wa<CR>
" Save All  and Quit
nnoremap   <F10>      :xa<CR>
xnoremap   <F10>      :xa<CR>
inoremap   <F10>      <ESC>:xa<CR>
tnoremap   <F10>      <C-W>:xa<CR>
" Close And Quit
nnoremap   <C-F10>    :confirm qa<CR>
xnoremap   <C-F10>    :confirm qa<CR>
inoremap   <C-F10>    <ESC>:confirm qa<CR>
tnoremap   <C-F10>    <C-W>:confirm qa<CR>
"}}}


" Edit {{{2
" Keymaps for editing operations

" Stay selection in indent mode
xnoremap  <silent> <             <gv
xnoremap  <silent> >             >gv

" Better copy in visual mode. Paste and dont loose clipboard
vnoremap  <silent> p            "_dP 

" Move selected text up and down - Alt-[Up|Down]
vnoremap  <silent> <A-j>            :m .+1<CR>== 
vnoremap  <silent> <A-k>            :m .-2<CR>== 
vnoremap  <silent> <A-Down>         :m .+1<CR>== 
vnoremap  <silent> <A-Up>           :m .-2<CR>== 

" Visual Block 
" Move text up and down - Alt-[Up|Down]
xnoremap  <silent> J           :move '>+1<CR>gv-gv 
xnoremap  <silent> K           :move '<-2<CR>gv-gv 
xnoremap  <silent> <A-j>       :move '>+1<CR>gv-gv 
xnoremap  <silent> <A-k>       :move '<-2<CR>gv-gv 
xnoremap  <silent> <A-Down>    :move '>+1<CR>gv-gv 
xnoremap  <silent> <A-Up>      :move '<-2<CR>gv-gv 


" Grep/Search word under cursor - F4, leader-g
" nnoremap  <F4>      :silent lgrep <C-R><C-W><CR>:lopen<CR>
" inoremap  <F4>      :<C-O>silent lgrep <C-R><C-W><CR>:lopen<CR>
" xnoremap  <F4>      :silent lgrep <C-R><C-W><CR>:lopen<CR>
if s:has_fzf &&  s:has_rg
    nnoremap  <F4>          :Rg <C-R><C-W><CR>
    inoremap  <F4>          :<C-O>Rg  <C-R><C-W><CR>
    xnoremap  <F4>          :Rg  <C-R><C-W><CR>
    nnoremap  <leader>g     :Rg <C-R><C-W><CR>
    xnoremap  <leader>g     :Rg  <C-R><C-W><CR>
else
    nnoremap  <F4>          :TDvimGrep <C-R><C-W>
    inoremap  <F4>          :<C-O>TDvimGrep  <C-R><C-W>
    xnoremap  <F4>          :TDvimGrep  <C-R><C-W>
    nnoremap  <leader>g     :TDvimGrep <C-R><C-W>
    xnoremap  <leader>g     :TDvimGrep  <C-R><C-W>
endif

" Grep/Search in project - C-F4
if s:has_fzf &&  s:has_rg
    nnoremap  <S-F4>          :Rg<CR>
    inoremap  <S-F4>          :<C-O>Rg<CR>
    xnoremap  <S-F4>          :Rg<CR>
else
    nnoremap  <F4>          :TDvimGrep 
    inoremap  <F4>          :<C-O>TDvimGrep  
    xnoremap  <F4>          :TDvimGrep  
endif

" Navigate Grep results. Navigate Location list entries
" Default mapped to []s
nmap <silent> [s :cprev<CR>
nmap <silent> ]s :cnext<CR>
nmap <silent> [S :cfirst<CR>
nmap <silent> ]S :clast<CR>

" Navigate Changes
" Default mapped to []c
nmap <silent> [c    g;
imap <silent> [c    <Esc>g;
vmap <silent> [c    g;
nmap <silent> ]c    g,
imap <silent> ]c    <Esc>g,
vmap <silent> ]c    g,





" }}}


" WindowManagement {{{2
" Operations to work with windows, tabs, etc ...

" Close Window - <leader>q
nnoremap  <silent> <leader>q          <C-w>c 
vnoremap  <silent> <leader>q          <C-w>c 
" Close All Help Windows - <leader>qh
nnoremap  <silent> <leader>qh         :call TDVimCloseAllWindowsByType('help')<CR> 
vnoremap  <silent> <leader>qh         :call TDVimCloseAllWindowsByType('help')<CR> 
" Close Preview Window - <leader>qp
nnoremap  <silent> <leader>qp         <C-W><C-Z> 
vnoremap  <silent> <leader>qp         <C-W><C-Z> 
" Close QuickFix Window - <leader>qq
nnoremap  <silent> <leader>qq         :cclose<CR> 
vnoremap  <silent> <leader>qq         <Esc>:cclose<CR> 
" Close Location Window - <leader>ql
nnoremap  <silent> <leader>ql         :lclose<CR> 
vnoremap  <silent> <leader>ql         <Esc>:lclose<CR> 
" Close Previous Window - <leader>qw
nnoremap  <silent> <leader>qw         :call TDVimClosePreviousWindow()<CR> 
vnoremap  <silent> <leader>qw         <Esc>:call TDVimClosePreviousWindow()<CR> 

" Jump to QuickFix Window - <leader>jq
nnoremap  <silent> <leader>jq         :call utils#JumpToWindowsByType( "quickfix" )<CR> 
xnoremap  <silent> <leader>jq         <ESC>:call utils#JumpToWindowsByType( "quickfix" )<CR> 
" Jump to Location Window - <leader>jl
nnoremap  <silent> <leader>jl         :call utils#JumpToWindowsByType( "location" )<CR> 
xnoremap  <silent> <leader>jl         <ESC>:call utils#JumpToWindowsByType( "location" )<CR> 
" Jump to Preview Window - <leader>jl
nnoremap  <silent> <leader>jp         :call utils#JumpToWindowsByType( "preview" )<CR> 
xnoremap  <silent> <leader>jp         <ESC>:call utils#JumpToWindowsByType( "preview" )<CR> 

" Jump to Location List Window {{{3
nnoremap <unique> <silent> <Plug>TdvimJumpToLocationWindow :call utils#JumpToWindowsByType( "location" )<CR>
vnoremap <unique> <silent> <Plug>TdvimJumpToLocationWindow <Esc>:call utils#JumpToWindowsByType( "location" )<CR>
inoremap <unique> <silent> <Plug>TdvimJumpToLocationWindow <Esc>:call utils#JumpToWindowsByType( "location" )<CR>

nmap <silent> <leader>jl <Plug>TdvimJumpToLocationWindow 
vmap <silent> <leader>jl <Plug>TdvimJumpToLocationWindow
" }}}

" Jump to Preview Window {{{3
nnoremap <unique> <silent> <Plug>TdvimJumpToPreviewWindow :call utils#JumpToWindowsByType( "preview" )<CR>
vnoremap <unique> <silent> <Plug>TdvimJumpToPreviewWindow <Esc>:call utils#JumpToWindowsByType( "preview" )<CR>
inoremap <unique> <silent> <Plug>TdvimJumpToPreviewWindow <Esc>:call utils#JumpToWindowsByType( "preview" )<CR>

nmap <silent> <leader>jp <Plug>TdvimJumpToPreviewWindow 
vmap <silent> <leader>jp <Plug>TdvimJumpToPreviewWindow
" }}}

" Close Window and Delete Buffer - <leader>x
nnoremap  <leader>x        :bdelete<CR> 
xnoremap  <leader>x        :bdelete<CR> 

" Vertical Split Window - <leader>s
nnoremap  <silent> <leader>s        <C-w>v 
vnoremap  <silent> <leader>s        <C-w>v 
" Horizontal Split Window - <leader>s
nnoremap  <silent> <leader>sh       <C-w>s 
vnoremap  <silent> <leader>sh       <C-w>s 

" Better window navigation - <leader>[Up|Down|Left|Right] {{{3
nnoremap  <silent> <C-h>    <C-w>h 
nnoremap  <silent> <C-l>    <C-w>l
nnoremap  <silent> <C-j>    <C-w>j
nnoremap  <silent> <C-k>    <C-w>k
nnoremap  <silent> <leader><Left>   <C-w>h
nnoremap  <silent> <leader><Right>  <C-w>l
nnoremap  <silent> <leader><Up>     <C-w>j 
nnoremap  <silent> <leader><Down>   <C-w>k
tnoremap  <silent> <C-h>    <C-w>h 
tnoremap  <silent> <C-l>    <C-w>l
tnoremap  <silent> <C-j>    <C-w>j
tnoremap  <silent> <C-k>    <C-w>k
tnoremap  <silent> <leader><Left>   <C-w>h
tnoremap  <silent> <leader><Right>  <C-w>l
tnoremap  <silent> <leader><Up>     <C-w>j 
tnoremap  <silent> <leader><Down>   <C-w>k
" }}}

" Explorer - F8, <leader>e
" Netrw
"nnoremap  <silent> <F8>       :Lex 20<cr> 
"nnoremap  <silent> <leader>e  :Lex 20<cr> 
" NErdtTree
nnoremap  <silent> <F8>       :NERDTreeToggle<cr> 
inoremap  <silent> <F8>       <C-O>:NERDTreeToggle<cr> 
xnoremap  <silent> <F8>       <ESC>:NERDTreeToggle<cr> 
" In Explorer - -
"nnoremap  <silent> -       :Explore<CR> 
"nnoremap  <silent> -       :Explore<CR> 

" Resize with arrows - Ctrl[Up|Down|Left|Right]
nnoremap  <silent> <C-Up>     :resize +2<CR> 
nnoremap  <silent> <C-Down>   :resize -2<CR> 
nnoremap  <silent> <C-Left>   :vertical resize -2<CR> 
nnoremap  <silent> <C-Right>  :vertical resize +2<CR> 
tnoremap  <silent> <C-Up>     :resize +2<CR> 
tnoremap  <silent> <C-Down>   :resize -2<CR> 
tnoremap  <silent> <C-Left>   :vertical resize -2<CR> 
tnoremap  <silent> <C-Right>  :vertical resize +2<CR> 

" Reset windows sizes - <leader>=
nnoremap  <silent> <leader>=   <C-w>= 
vnoremap  <silent> <leader>=   <C-w>= 
tnoremap  <silent> <leader>=   <C-w>= 

" Navigate buffers - []b
nnoremap  <silent> <S-l>=   :bnext<CR> 
nnoremap  <silent> <S-h>=   :bprevious<CR> 
nnoremap  <silent> <[b>=    :bnext<CR> 
nnoremap  <silent> <]b>=    :bprevious<CR> 

" Switch to Previous window
nnoremap  <silent> <leader>p   <C-w>p 
" Switch to Previous buffer - Ctrl-F3, TAB
nnoremap  <silent> <C-F3>   :e #<CR>
vnoremap  <silent> <C-F3>   :e #<CR>
inoremap  <silent> <C-F3>   <ESC>:e #<CR>
"nnoremap  <silent> <leader><TAB>   :e #<CR>
nnoremap  <silent> <TAB>   :e #<CR>
vnoremap  <silent> <leader><TAB>   :e #<CR>
" Switch current window to Previous buffer - Shift-TAB
nnoremap  <silent> <S-TAB>   <C-w>x

" Navigate Buffers - F3, <leader>b
if s:has_fzf
    nnoremap   <F3>   :Buffers<cr>
    vnoremap   <F3>   :Buffers<cr>
    inoremap   <F3>   <ESC>:Buffers<cr>
else
    nnoremap   <F3>   :files<cr>:b<space>
    vnoremap   <F3>   :files<cr>:b<space>
    inoremap   <F3>   <ESC>:files<cr>:b<space>
endif

" }}}

" CommandLine {{{2
" Keymaps to work from the command line

" }}}

" Development {{{2
" Operations usually used when programing

" Toggle comments
nmap <silent> <F5>       <Plug>NERDCommenterToggle
vmap <silent> <F5>       <Plug>NERDCommenterToggle
imap <silent> <F5>       <Esc>\c<Space>
nmap <silent> <leader>ct <Plug>NERDCommenterToggle
vmap <silent> <leader>ct <Plug>NERDCommenterToggle

" Toggle & Yank comments
nmap <silent> <S-F5>       <Plug>NERDCommenterYank
vmap <silent> <S-F5>       <Plug>NERDCommenterYank
imap <silent> <S-F5>       <Esc>\c<Space>
nmap <silent> <leader>cy <Plug>NERDCommenterYank
vmap <silent> <leader>cy <Plug>NERDCommenterYank

" Multiline Comments
nmap <silent> <C-F5>     <Plug>NERDCommenterSexy
vmap <silent> <C-F5>     <Plug>NERDCommenterSexy
imap <silent> <C-F5>     <Esc>\cs
nmap <silent> <leader>cs <Plug>NERDCommenterSexy
vmap <silent> <leader>cs <Plug>NERDCommenterSexy

" Inspect and jump to tags
if s:has_fzf
    nnoremap   <F6>   :Tags<CR>
    xnoremap   <F6>   :Tags<CR>
else
    nnoremap   <F6>   :tjump <C-r><C-w><space>
    xnoremap   <F6>   :tjump <C-r><C-w><space>
endif
" Unimpaired tags navigation style with []t
nnoremap   ]t   :tjump <C-r><C-w><CR>
nnoremap   [t   <C-t>
" Inspect and preview tag
nnoremap   <S-F6>   :ptjump <C-r><C-w><space>
xnoremap   <S-F6>   :ptjump <C-r><C-w><space>


" Create tags file
nnoremap   <F11>   :TDVimMakeTags <CR>

" Autocomplete using Previous and Next
inoremap   <TAB>    <C-R>=TDVimTabAutocompleteWrapper("backward")<CR>
inoremap   <S-TAB>  <C-R>=TDVimTabAutocompleteWrapper("forward")<CR>
" keymap("i", "<tab>", "<c-r>=utils#TabAutocompleteWrapper(\"backward\")<cr>", opts)
" keymap("i", "<s-tab>", "<c-r>=utils#TabAutocompleteWrapper(\"forward\")<cr>", opts)


" }}}

" Terminal {{{2
" Termnal keymaps
" nnoremap <F7>       :wincmd b \| botright terminal<CR>
" Open terminal at bottom
nnoremap <F7>       :TDVimOpenTerminal<CR>
nnoremap <leader>t  :TDVimOpenTerminal<CR>
" Minimize terminal window and jump to previous window
tnoremap <F7>       <C-W>1_<C-W>W
" }}}


" }}}


" Diff mode specific options {{{
set diffopt=filler,vertical
if &diff
    "	setup for diff mode
endif

" }}}

" Completion {{{
" Completion options
set noshowmode
"set shortmess+=c
set shortmess=aTt
set noinfercase
set belloff+=ctrlg " If Vim beeps during completion
set belloff+=cursor " If Vim beeps during scrolling
set belloff+=all " If Vim beeps during scrolling
set completeopt-=preview
set completeopt+=menuone
set completeopt-=popup
" set completeopt+=noinsert
" set completeopt+=noselect
set completepopup=height:10,width:60,highlight:InfoPopu

" Sources for searching in completion mode
" Only include current buffer and buffer in other windows only
set complete=.,w,b,t
" Set window splits to be at bottom by default, used by preview window and
" quckfix
set splitbelow
" time to wait for a mapped sequence to complete (in milliseconds)
set timeoutlen=500
" }}}

"
" Autocommands and Events {{{
"

" Only do this part when compiled with support for autocommands.
if has("autocmd")
    " Enable file type detection.
    filetype plugin indent on

    " Setup events autocommands
    " Misc
    augroup tdvimMisc
        " Highlight type for extra white spaces at the end of a line
        autocmd ColorScheme * highlight ExtraWhitespace ctermbg=lightred guibg=lightred
        autocmd Syntax python,cpp,c,sh,csh,vim highlight ExtraWhitespace ctermbg=lightred guibg=lightred
    augroup END
	autocmd VimEnter * call s:SetFancyUI()
        if g:tdvim_dev_mode
            autocmd VimEnter * echomsg "TDVim (Dev Mode)" . $TDVIMVERSION . " loaded"
        else
            autocmd VimEnter * echomsg "TDVim " . $TDVIMVERSION . " loaded"
        endif
    augroup END
    " AfterBufferRead
    augroup tdvimAftertBufferRead
        " When editing a file, always jump to the last known cursor position.
        " Don't do it when the position is invalid or when inside an event handler
        " (happens when dropping a file on gvim).
        autocmd BufRead *
                    \ if line("'\"") > 0 && line("'\"") <= line("$") |
                    \   exe "normal! g`\"" |
                    \ endif
        " Change local path to the folder containing the current buffer:
        autocmd BufRead * call s:SetLocalPath()
        autocmd BufRead quickfix call s:SetupAuxBuffer()
        " Show bad spaces at the end of code lines:
        au BufRead,BufNewFile *.py,*.pyw,*.c,*.cpp,*.vim,*.h match ExtraWhitespace  /\s\+$/
    augroup END
    " BufEnter
    augroup tdvimBufEnter
        " Set local path to path of current file
        autocmd BufEnter * call s:SetLocalPath()
        " Call TDVim Project
        "autocmd BufEnter * call utils#ProjectSettings(expand("<afile>:p:h"), 0)
        " Setup only read buffer
        autocmd BufEnter * call s:OnlyReadSetup()
    augroup END
    " BufLeave
    "augroup tdvimBufLeave
        "autocmd BufLeave * echomsg "Leaving the buf"
    "augroup END
    " BufWinEnter
    augroup tdvimWinNew
        autocmd WinNew * call s:PreviewWindowSetup()
    augroup END
    augroup tdvimWinEnter
        autocmd WinEnter * call s:PreviewWindowSetup()
    augroup END
    " BufWinLeave
    augroup tdvimWinLeave
        autocmd WinLeave * call s:LeavePreviewWindowSetup()
    augroup END
    " BufAdd
    "augroup tdvimBufAdd
        " Setup quickfix and preview windows keymaps
        "autocmd BufAdd  * if &buftype == 'quickfix' | echo 'winenter' | endif
        "autocmd BufAdd  * echomsg "Adding buffer " . &buftype
        "autocmd BufAdd qf call utils#SetupAuxBuffer()
    "augroup END
     "FileTypes
     "
    augroup tdvimFileTypes
	"autocmd Filetype *
		    "\	if &omnifunc == "" |
		    "\		setlocal omnifunc=syntaxcomplete#Complete |
		    "\	endif
        autocmd! FileType nerdtree call s:SetupNERDTreeBuffer()
        autocmd! BufRead,BufNewFile *.usd set filetype=usd
        autocmd! BufRead,BufNewFile *.usda set filetype=usda
        autocmd! BufNewFile,BufRead *.hjson setlocal filetype=hjson
    augroup END
    " SessionLoadPost
    "augroup tdvimSessionLoadPost
    "augroup END

    " CursorHold
    if s:has_git
        autocmd! CursorHold * ++nested call TDVimUpdateCurrentGitBranch()
    endif
    augroup tdvimCursorHold
        autocmd! CursorHold * ++nested call TDVimUpdateDevIconFileType()
        "autocmd! CursorHold * ++nested call utils#UpdateDevIconFileType()
        "autocmd! CursorHold leaderf ++nested normal <C-I>
    augroup END

else
    set autoindent		" always set autoindenting on
endif " has("autocmd")

" }}}


" Setup Plugins {{{


" NERDTree {{{2
" let g:NERDTreeHijackNetrw = 1 " Use NERD Tree instead of netrw

" The next lines are really commented the rest are commented for testing.
"let g:NERDTreeDisableFileExtensionHighlight = 1
"let g:NERDTreeDisableExactMatchHighlight = 1
"let g:NERDTreeDisablePatternMatchHighlight = 1

let g:NERDTreeFileExtensionHighlightFullName = 1
" let g:NERDTreeExactMatchHighlightFullName = 1
" let g:NERDTreePatternMatchHighlightFullName = 1
" let g:NERDTreeLimitedSyntax = 1
let NERDTreeIgnore=['\.swo$', '\.swp$','\.pyc$', '\.o$','\~$']
let NERDTreeAutoDeleteBuffer = 1

" NERDTree Git
let g:NERDTreeGitStatusEnable=1
let g:NERDTreeGitStatusIndicatorMapCustom = {
            \ "Modified"  : "✹",
            \ "Staged"    : "✚",
            \ "Untracked" : "✭",
            \ "Renamed"   : "➜",
            \ "Unmerged"  : "═",
            \ "Deleted"   : "✖",
            \ "Dirty"     : "✗",
            \ "Clean"     : "✔︎",
            \ 'Ignored'   : '☒',
            \ "Unknown"   : "?"
            \ }

" NERD Commenter:
let g:NERDMenuMode = 0 " Disable menu

"}}}

"Lightline {{{2
" use lightline-buffer in lightline
let g:lightline = {
  \ 'tabline': {
          \ 'left': [ [ 'buffers' ], ],
          \ 'right': [ [ 'close' ], ],
          \ },
  \ 'component_expand': {
          \ 'buffers' : 'lightline#bufferline#buffers',
          \ },
  \ 'component_type': {
          \ 'buffers': 'tabsel',
          \ },
  \ 'component_function': {
          \ 'filetypeicon': 'TDVimLightlineDeviconsFiletype',
          \ 'fileformat': 'TDVimLightlineDeviconsFileformat',
          \ 'modifiedicon': 'TDVimLightlineModified',
          \ 'readonly': 'TDVimLightlineReadonly',
          \ 'extrainfo': 'TDVimLightlineExtraInfo',
          \ 'tagsgen': 'utils#LightlineGutentags',
          \ 'git': 'TDVimLightlineGit',
          \ 'githunksummary': 'TDVimGitHunksummary',
          \ },
  \ 'component': {
          \ 'filename': '%{TDVimLightlineFilename()}',
          \ 'mode': '%{TDVimLightlineMode()}',
          \ 'inactivemode': '%{TDVimLightlineInactiveMode()}',
  \       },
  \'subseparator' : { 'left': '|', 'right': '|' },
  \ }
                "\ 'lineinfo': '%{utils#LightlineLineInfo()}',
          "\ 'lineinfo': '%{TDVimLightlineLineInfo()}',
  " \ 'tabline': {
  "         \ 'left': [ [ 'sessioninfo' ], [ 'bufferinfo' ], [ 'bufferbefore', 'buffercurrent', 'bufferafter' ], ],
  "         \ 'right': [ [ 'close' ], ],
  "         \ },
          " \ 'sessioninfo': 'utils#SessionName',

if has ('gui_running')
    "let g:lightline.active = {
                "\ 'left': [ [ 'mode', 'paste' ], [ 'readonly', 'filetypeicon', 'filename', 'modifiedicon' ], [ 'extrainfo', 'tagsgen' ] ],
                "\ 'right': [ [ 'lineinfo' ], [ 'percent' ], [ 'git' ] ]
                \   }
    if s:has_git
        let g:lightline.active = {
                    \ 'left': [ [ 'mode', 'paste' ], [ 'readonly', 'filetypeicon', 'filename', 'modifiedicon', 'githunksummary' ], [ 'extrainfo', 'tagsgen' ] ],
                    \ 'right': [ [ 'lineinfo' ], [ 'percent' ], [ 'git' ] ]
                    \   }
    else
        let g:lightline.active = {
                    \ 'left': [ [ 'mode', 'paste' ], [ 'readonly', 'filetypeicon', 'filename', 'modifiedicon' ], [ 'extrainfo', 'tagsgen' ] ],
                    \ 'right': [ [ 'lineinfo' ], [ 'percent' ] 
                    \   }
    endif
else
    if s:has_git
        let g:lightline.active = {
                    \ 'left': [ [ 'mode', 'paste' ], [ 'readonly', 'filename', 'modifiedicon', 'githunksummary' ], [ 'extrainfo', 'tagsgen' ] ],
                    \ 'right': [ [ 'lineinfo' ], [ 'percent' ], [ 'git', 'filetype' ] ]
                    \   }
    else
        let g:lightline.active = {
                    \ 'left': [ [ 'mode', 'paste' ], [ 'readonly', 'filename', 'modifiedicon' ], [ 'extrainfo', 'tagsgen' ] ],
                    \ 'right': [ [ 'lineinfo' ], [ 'percent' ], [ 'filetype' ] ]
                    \   }
    endif
endif

if s:has_git
    let g:lightline.inactive = {
                \ 'left': [ [ 'inactivemode', 'filename', 'modifiedicon' ] ],
                \ 'right': [ [ 'lineinfo' ],
                \            [ 'git', 'percent' ] ] }
else
    let g:lightline.inactive = {
                \ 'left': [ [ 'inactivemode', 'filename', 'modifiedicon' ] ],
                \ 'right': [ [ 'lineinfo' ],
                \            [ 'percent' ] ] }
endif
" lightline-buffer
" Always enable tabline, needed by lightline-bufferline
set showtabline=2
" Dont use GUI tabs in GUI mode, instead use text tabline. Needed by
" tabline buffers plugins
set guioptions-=e
" lightline-buffer function settings
" let g:lightline_buffer_show_bufnr = 1
" let g:lightline_buffer_rotate     = 0
" let g:lightline_buffer_fname_mod  = ':t'
" let g:lightline_buffer_excludes   = ['vimfiler', 'nerdtree', 'tagbar', 'help', 'quickfix', 'terminal']
" let g:lightline_buffer_maxflen    = 30
" let g:lightline_buffer_maxfextlen = 3
" let g:lightline_buffer_minflen    = 16
" let g:lightline_buffer_minfextlen = 3
" let g:lightline_buffer_reservelen = 20
" let g:lightline#bufferline#enable_devicons = 0
let g:lightline#bufferline#disable_more_buffers_indicator = 1
let g:lightline#bufferline#show_number = 2
let g:lightline#bufferline#filter_by_tabpage = 1
" Default color
let g:lightline.colorscheme = "PaperColor"

" }}}

" FZF {{{2
" files command
if s:has_fd
    let $FZF_DEFAULT_COMMAND = 'fd'
elseif s:has_rg
    let $FZF_DEFAULT_COMMAND = 'rg --files'
endif
" Layout
" Open using split at bottom. Faster than floating window
let  fzf_layout = {'down':'~40%'}
" Customize fzf colors to match your color scheme                                          
" - fzf#wrap translates this to a set of `--color` options                                 
let g:fzf_colors =                                                                         
            \ { 'fg':      ['fg', 'Normal'],                                                           
            \ 'bg':      ['bg', 'Normal'],                                                           
            \ 'hl':      ['fg', 'Comment'],                                                          
            \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],                             
            \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],                                       
            \ 'hl+':     ['fg', 'Statement'],                                                        
            \ 'info':    ['fg', 'PreProc'],                                                          
            \ 'border':  ['fg', 'Ignore'],                                                           
            \ 'prompt':  ['fg', 'Conditional'],                                                      
            \ 'pointer': ['fg', 'Exception'],                                                        
            \ 'marker':  ['fg', 'Keyword'],                                                          
            \ 'spinner': ['fg', 'Label'],                                                            
            \ 'header':  ['fg', 'Comment'] } 
" Improve colors in FZF in Gvim on windows:
if s:GetOS() == 3
    "Windows
    set termwintype=conpty
    let g:fzf_force_termguicolors = 1
endif
" Enable preview based on availability of bash
if !s:has_bash
    " Empty value to disable preview window altogether
    let g:fzf_preview_window = []
    " Files
    if s:has_bat
        command! -bang -nargs=? -complete=dir Files
                    \ call fzf#vim#files(<q-args>, {'options': ['--prompt=Files:> ', '--layout=reverse', '--info=inline', '--preview', 'bat --color=always --pager=never --style=full {}']}, <bang>0)
    elseif s:has_cat
        command! -bang -nargs=? -complete=dir Files
                    \ call fzf#vim#files(<q-args>, {'options': ['--prompt=Files:> ', '--layout=reverse', '--info=inline', '--preview', 'cat {}']}, <bang>0)
    else
        command! -bang -nargs=? -complete=dir Files
                    \ call fzf#vim#files(<q-args>, {'options': ['--prompt=Files:> ', '--layout=reverse', '--info=inline']}, <bang>0)
    endif
endif
" }}}
" Setup Plugins }}}


" Project Mode {{{
" Overrides for Project Mode
" If vim is opened in a directory then enable some special settings to
" work in a project, assuming the current folder is the project root
if g:tdvim_dev_mode
    " Add devmode folder to runtime to load plugins availalbe only in dev mode
    "let s:tdvimroot = substitute($TDVIMROOT, "\\", "/", "g")
    "Add TDVim to runtim path
    "execute "set rtp^=" . s:tdvimroot
    "execute "set rtp+=" . s:tdvimroot . "/after"
    " Relative path of script file:
    "let s:tdvim_install_path = expand('<sfile>')
    let g:tdvim_install_path = fnamemodify(resolve(expand('<sfile>:p')), ':h')
    let s:tdvim_devmode_path = g:tdvim_install_path . "/devmode"
    execute "set rtp^=" . s:tdvim_devmode_path
    execute "set rtp+=" . s:tdvim_devmode_path . "/after"
    "echomsg "TDVim install location: " . s:tdvim_devmode_path

    " Set project folder and tdvim config skeleton for project.
    " Preapre session magement for project
    " Also prepare Rooter and window title for session
    if s:has_git
        " Setup globla vars for project mode
        let s:root = system('git rev-parse --show-toplevel')
        let g:tdvim_proj_root = trim(s:root)
        "echomsg "Project root: " . g:tdvim_proj_root
        let g:tdvim_proj_name = fnamemodify( g:tdvim_proj_root, ':t' )
        let g:tdvim_proj_root_config = g:tdvim_proj_root . '/.tdvim'
        "echomsg "Project config folder: " . g:tdvim_proj_root_config
        let s:has_tdvim_root = 0
        let s:has_tdvim_proj_config = 0
        if !isdirectory(g:tdvim_proj_root_config)
            "echomsg "Init tdvim config for project " . g:tdvim_proj_name
            let s:has_tdvim_root = mkdir(g:tdvim_proj_root_config, "p", 0o777)
        else
            let s:has_tdvim_root = 1
        endif
        if s:has_tdvim_root
            let s:tdvim_proj_config = g:tdvim_proj_root_config . "/project.vim"
            if !filereadable(expand(s:tdvim_proj_config))
                "echomsg "Crete project.vim"
                call writefile( ["\" Project config file for tdvim", "\" Use this to setup vim for your project"], s:tdvim_proj_config )
                let s:has_tdvim_proj_config = 1
            else
                let s:has_tdvim_proj_config = 1
            endif
            if s:has_tdvim_proj_config
                " Source project config on VimEnter
                autocmd VimEnter * nested exe 'source ' . s:tdvim_proj_config | echomsg "Project config loaded: " . s:tdvim_proj_config
            endif
        endif
        " Rooter. move to git root folder.
        " Globally move to project root, set creation of buffer variable with
        " bufer git rootm needed for submodules,
        " In SetLocal() we use it to do a lcd .
        exe "cd " . g:tdvim_proj_root
        autocmd BufRead * cd %:p:h | let b:tdvim_proj_root = system('git rev-parse --show-toplevel') 

        " Window title
        set title
        autocmd BufEnter * let &titlestring = expand("%:t") . " (" . expand("%:p:h") . ")" . "  |> " . fnamemodify(g:tdvim_proj_name, ':t') . " <|   " . "TDVim " . $TDVIMVERSION
        
    endif
    " Simple session management
    " Session management in tdvim dev mode, save session on leave and restore
    " on enter
    autocmd VimLeave * call TDVimSaveSess()
    autocmd VimEnter * nested silent! call TDVimRestoreSess()
    " Load project setup on Enter
    autocmd VimEnter * nested exe 'source ' . s:tdvim_proj_config
    " Session commands
    command! TDVimSaveSession call TDVimSaveSess()
    command! TDVimRestoreSession call TDVimRestoreSess()

    "
    " Keymaps for dev mode
    " NERDTree using VCS mode (open in root project)
    " NErdtTree
    nunmap <F8>
    xunmap <F8>
    iunmap <F8>
    nnoremap  <silent> <F8>       :NERDTreeToggleVCS<cr> 
    inoremap  <silent> <F8>       <C-O>:NERDTreeToggleVCS<cr> 
    xnoremap  <silent> <F8>       <ESC>:NERDTreeToggleVCS<cr> 
    " Open Files in current location - S-F3, <leader>o
    " Remap S-F3 if using FZF to use GFile instead of Files
    if s:has_fzf
        nunmap <S-F3>
        vunmap <S-F3>
        iunmap <S-F3>
        nnoremap   <S-F3>   :GFiles<CR>
        vnoremap   <S-F3>   :GFiles<CR>
        inoremap   <S-F3>   <ESC>:GFiles<CR>
    endif
    " Git keymaps:
    " Navigate hunks
    nmap ]h <Plug>(GitGutterNextHunk)
    nmap [h <Plug>(GitGutterPrevHunk)
    " - Diff  with index
    nnoremap   <F9>   :GitGutterDiffOrig<CR>
    " - Fold Hunks
    nnoremap   <C-F9>   :GitGutterFold<CR>
    " - Show hunks in QuickFix
    command! TDVimGitHunks :GitGutterQuickFix | copen
    nnoremap   <S-F9>   :TDVimGitHunks<CR>
    " Symbols keymaps
    " Use FzfFunky if fzf available
    if s:has_fzf
        nnoremap   <F6>   :FzfFunky<CR>
        xnoremap   <F6>   :FzfFunky<CR>
    endif



    " Disable autochdir:
    set noautochdir
    " Enable Autowrite:
    set autowriteall
    " Autosave:
    let s:autoPattern = "*.{c,h,[ch]pp,[acjt]s,inl,cg,cgfx,fx,py,bat,cmd,jam,vim,yml,yaml,vsprops,erb,rb,html,htm},SCons*,[mM]akefile,*vimrc"
    execute "autocmd FocusLost"     s:autoPattern   "silent! wall"
    execute "autocmd CursorHold " s:autoPattern " silent! update"


    " Create/Update tags file
    " Set wildoptions+=tagfile
    " Set wildoptions+=fuzzy
endif

" }}}

" Load user settings {{{
if has('unix')
  " unix-like platform (including Cygwin)
  if filereadable($HOME . "/myvimrc")
    source $HOME/myvimrc
  elseif filereadable($HOME . "/.myvimrc")
    source $HOME/.myvimrc
  elseif filereadable($HOME . "/_myvimrc")
    source $HOME/_myvimrc
  else
    " Do nothing
  endif
else
  " probably Windows
  if has("win32")
    if filereadable($HOME . "/myvimrc")
      source $HOME/myvimrc
    elseif filereadable($HOME . "/_myvimrc")
      source $HOME/_myvimrc
    elseif filereadable($HOME . "/.myvimrc")
      source $HOME/.myvimrc
    else
      " Do nothing
    endif
  endif
endif

"}}}

" TDVim version
let $TDVIMVERSION="0.4.5"

" vim: ts=8 ft=vim nowrap fdm=marker
